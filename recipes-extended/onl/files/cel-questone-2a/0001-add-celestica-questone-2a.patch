From 20c41467cb9446b73d349c4903c4498e4160ae77 Mon Sep 17 00:00:00 2001
From: Peerapong Jaipakdee <pjaipakdee@celestica.com>
Date: Mon, 14 Sep 2020 17:51:55 +0700
Subject: [PATCH 1/7] add celestica questone 2a

Add Celestica Questone-2a taken from [1], all commits squashed into one
for easier addition.

[1] https://github.com/SW-CSV/OpenNetworkLinux/tree/Questone2a_v0.0.3

Upstream-State: Inappropriate [Not for us to upstream]
[jonas.gorski: squashed into one commit]
Signed-off-by: Jonas Gorski <jonas.gorski@bisdn.de>
---
 .../celestica/x86-64/questone-2a/Makefile     |    1 +
 .../x86-64/questone-2a/modules/Makefile       |    1 +
 .../x86-64/questone-2a/modules/PKG.yml        |    1 +
 .../questone-2a/modules/builds/Makefile       |    7 +
 .../questone-2a/modules/builds/src/Makefile   |    2 +
 .../modules/builds/src/mc24lc64t.c            |  173 ++
 .../questone-2a/modules/builds/src/optoe.c    | 1147 +++++++++
 .../builds/src/questone2a_baseboard_cpld.c    |  409 ++++
 .../builds/src/questone2a_switchboard.c       | 2148 +++++++++++++++++
 .../questone-2a/modules/builds/src/sff-8436.h |   31 +
 .../modules/builds/src/sff_8436_eeprom.c      |  982 ++++++++
 .../x86-64/questone-2a/onlp/Makefile          |    1 +
 .../celestica/x86-64/questone-2a/onlp/PKG.yml |    1 +
 .../x86-64/questone-2a/onlp/builds/Makefile   |    2 +
 .../questone-2a/onlp/builds/lib/Makefile      |    2 +
 .../questone-2a/onlp/builds/onlpdump/Makefile |    2 +
 .../builds/x86_64_cel_questone_2a/.module     |    1 +
 .../builds/x86_64_cel_questone_2a/Makefile    |    9 +
 .../module/auto/make.mk                       |    9 +
 .../module/auto/x86_64_cel_questone_2a.yml    |   47 +
 .../x86_64_cel_questone_2a.x                  |   14 +
 .../x86_64_cel_questone_2a_config.h           |  127 +
 .../x86_64_cel_questone_2a_dox.h              |   26 +
 .../x86_64_cel_questone_2a_porting.h          |  107 +
 .../x86_64_cel_questone_2a/module/make.mk     |   10 +
 .../module/src/Makefile                       |    9 +
 .../x86_64_cel_questone_2a/module/src/fani.c  |   88 +
 .../x86_64_cel_questone_2a/module/src/ledi.c  |  169 ++
 .../x86_64_cel_questone_2a/module/src/make.mk |    9 +
 .../module/src/platform.c                     | 1099 +++++++++
 .../module/src/platform.h                     |  155 ++
 .../x86_64_cel_questone_2a/module/src/psui.c  |   82 +
 .../x86_64_cel_questone_2a/module/src/sfpi.c  |  203 ++
 .../x86_64_cel_questone_2a/module/src/sysi.c  |  135 ++
 .../module/src/thermali.c                     |   94 +
 .../src/x86_64_cel_questone_2a_config.c       |   76 +
 .../module/src/x86_64_cel_questone_2a_enums.c |    6 +
 .../module/src/x86_64_cel_questone_2a_int.h   |   11 +
 .../module/src/x86_64_cel_questone_2a_log.c   |   18 +
 .../module/src/x86_64_cel_questone_2a_log.h   |   12 +
 .../src/x86_64_cel_questone_2a_module.c       |   24 +
 .../module/src/x86_64_cel_questone_2a_ucli.c  |   50 +
 .../questone-2a/platform-config/Makefile      |    1 +
 .../questone-2a/platform-config/r0/Makefile   |    1 +
 .../questone-2a/platform-config/r0/PKG.yml    |    1 +
 .../r0/src/lib/x86-64-cel-questone-2a-r0.yml  |   34 +
 .../x86_64_cel_questone_2a_r0/__init__.py     |   75 +
 47 files changed, 7612 insertions(+)
 create mode 100755 packages/platforms/celestica/x86-64/questone-2a/Makefile
 create mode 100755 packages/platforms/celestica/x86-64/questone-2a/modules/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/PKG.yml
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/mc24lc64t.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/optoe.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_baseboard_cpld.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_switchboard.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff-8436.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff_8436_eeprom.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/PKG.yml
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/lib/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/onlpdump/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/.module
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/make.mk
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/x86_64_cel_questone_2a.yml
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a.x
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_dox.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_porting.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/make.mk
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/Makefile
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/fani.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/ledi.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/make.mk
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/psui.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sfpi.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sysi.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/thermali.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_config.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_enums.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_int.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.h
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_module.c
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_ucli.c
 create mode 100755 packages/platforms/celestica/x86-64/questone-2a/platform-config/Makefile
 create mode 100755 packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/Makefile
 create mode 100755 packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/PKG.yml
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/lib/x86-64-cel-questone-2a-r0.yml
 create mode 100644 packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/python/x86_64_cel_questone_2a_r0/__init__.py

diff --git a/packages/platforms/celestica/x86-64/questone-2a/Makefile b/packages/platforms/celestica/x86-64/questone-2a/Makefile
new file mode 100755
index 000000000000..dc1e7b86f0b2
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/Makefile
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/Makefile b/packages/platforms/celestica/x86-64/questone-2a/modules/Makefile
new file mode 100755
index 000000000000..003238cf6d4e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/Makefile
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/PKG.yml b/packages/platforms/celestica/x86-64/questone-2a/modules/PKG.yml
new file mode 100644
index 000000000000..3af237240e42
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/PKG.yml
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/platform-modules.yml ARCH=amd64 VENDOR=celestica BASENAME=x86-64-cel-questone-2a KERNELS="onl-kernel-4.14-lts-x86-64-all:amd64"
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/Makefile b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/Makefile
new file mode 100644
index 000000000000..efc216337d3c
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/Makefile
@@ -0,0 +1,7 @@
+KERNELS := onl-kernel-4.14-lts-x86-64-all:amd64
+#KMODULES := $(wildcard *.c)
+KMODULES := src
+VENDOR := celestica
+BASENAME := x86-64-cel-questone-2a
+ARCH := x86_64
+include $(ONL)/make/kmodule.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/Makefile b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/Makefile
new file mode 100644
index 000000000000..9bb403925a53
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/Makefile
@@ -0,0 +1,2 @@
+KBUILD_CFLAGS+=-DQUESTONE2A
+obj-m := mc24lc64t.o questone2a_switchboard.o questone2a_baseboard_cpld.o sff_8436_eeprom.o optoe.o
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/mc24lc64t.c b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/mc24lc64t.c
new file mode 100644
index 000000000000..ae79770a4d8e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/mc24lc64t.c
@@ -0,0 +1,173 @@
+/*
+ * mc24lc64t.c - driver for Microchip 24LC64T
+ *
+ * Copyright (C) 2017 Celestica Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+
+#define EEPROM_SIZE 8192  //mc24lt64t eeprom size in bytes.
+
+struct mc24lc64t_data {
+        struct mutex            update_lock;
+};
+
+static ssize_t mc24lc64t_read(struct file *filp, struct kobject *kobj,
+                            struct bin_attribute *bin_attr,
+                            char *buf, loff_t off, size_t count)
+{
+        struct i2c_client *client = kobj_to_i2c_client(kobj);
+        struct mc24lc64t_data *drvdata = i2c_get_clientdata(client);
+        unsigned long timeout, read_time, i = 0;
+        int status;
+
+        mutex_lock(&drvdata->update_lock);
+
+        if (i2c_smbus_write_byte_data(client, off>>8, off))
+        {
+                status = -EIO;
+                goto exit;
+        }
+
+        msleep(1);
+
+begin:
+
+        if (i < count)
+        {
+                timeout = jiffies + msecs_to_jiffies(25); /* 25 mS timeout*/
+                do {
+                        read_time = jiffies;
+
+                        status = i2c_smbus_read_byte(client);
+                        if (status >= 0)
+                        {
+                                buf[i++] = status;
+                                goto begin;
+                        }
+                } while (time_before(read_time, timeout));
+
+                status = -ETIMEDOUT;
+                goto exit;
+        }
+
+        status = count;
+
+exit:
+        mutex_unlock(&drvdata->update_lock);
+
+        return status;
+}
+
+static ssize_t mc24lc64t_write (struct file *filp, struct kobject *kobj,
+                            struct bin_attribute *bin_attr,
+                            char *buf, loff_t off, size_t count){
+
+    struct i2c_client *client = kobj_to_i2c_client(kobj);
+    struct mc24lc64t_data *drvdata = i2c_get_clientdata(client);
+    unsigned long timeout, write_time, i = 0;
+    int status;
+    u16 value;
+
+    mutex_lock(&drvdata->update_lock);
+
+begin:
+    if (i < count){
+        timeout = jiffies + msecs_to_jiffies(25); /* 25 mS timeout*/
+        value = (buf[i] << 8)| off;
+        do {
+                write_time = jiffies;
+                status = i2c_smbus_write_word_data(client, off>>8, value);
+                if (status >= 0)
+                {
+                    // increase offset
+                    off++;
+                    // increase buffer index
+                    i++;
+                    goto begin;
+                }
+        } while (time_before(write_time, timeout));
+        status = -ETIMEDOUT;
+        goto exit;
+    }
+    status = count;
+
+exit:
+    mutex_unlock(&drvdata->update_lock);
+    return status;
+}
+
+static struct bin_attribute mc24lc64t_bit_attr = {
+        .attr = {
+                .name = "eeprom",
+                .mode = S_IRUGO | S_IWUGO,
+        },
+        .size = EEPROM_SIZE,
+        .read = mc24lc64t_read,
+        .write = mc24lc64t_write,
+};
+
+static int mc24lc64t_probe(struct i2c_client *client,
+                         const struct i2c_device_id *id)
+{
+        struct i2c_adapter *adapter = client->adapter;
+        struct mc24lc64t_data *drvdata;
+        int err;
+
+        if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE_DATA
+                                     | I2C_FUNC_SMBUS_READ_BYTE))
+                return -EPFNOSUPPORT;
+
+        if (!(drvdata = devm_kzalloc(&client->dev,
+                        sizeof(struct mc24lc64t_data), GFP_KERNEL)))
+                return -ENOMEM;
+
+        i2c_set_clientdata(client, drvdata);
+        mutex_init(&drvdata->update_lock);
+
+        err = sysfs_create_bin_file(&client->dev.kobj, &mc24lc64t_bit_attr);
+
+        return err;
+}
+
+static int mc24lc64t_remove(struct i2c_client *client)
+{
+        struct mc24lc64t_data *drvdata = i2c_get_clientdata(client);
+        sysfs_remove_bin_file(&client->dev.kobj, &mc24lc64t_bit_attr);
+
+        return 0;
+}
+
+static const struct i2c_device_id mc24lc64t_id[] = {
+        { "24lc64t", 0 },
+        { }
+};
+MODULE_DEVICE_TABLE(i2c, mc24lc64t_id);
+
+static struct i2c_driver mc24lc64t_driver = {
+        .driver = {
+                .name   = "mc24lc64t",
+                .owner = THIS_MODULE,
+        },
+        .probe          = mc24lc64t_probe,
+        .remove         = mc24lc64t_remove,
+        .id_table       = mc24lc64t_id,
+};
+
+module_i2c_driver(mc24lc64t_driver);
+
+MODULE_AUTHOR("Abhisit Sangjan <asang@celestica.com>");
+MODULE_DESCRIPTION("Microchip 24LC64T Driver");
+MODULE_LICENSE("GPL");
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/optoe.c b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/optoe.c
new file mode 100644
index 000000000000..c22b92a29abe
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/optoe.c
@@ -0,0 +1,1147 @@
+/*
+ * optoe.c - A driver to read and write the EEPROM on optical transceivers
+ * (SFP, QSFP and similar I2C based devices)
+ *
+ * Copyright (C) 2014 Cumulus networks Inc.
+ * Copyright (C) 2017 Finisar Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Freeoftware Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/*
+ *	Description:
+ *	a) Optical transceiver EEPROM read/write transactions are just like
+ *		the at24 eeproms managed by the at24.c i2c driver
+ *	b) The register/memory layout is up to 256 128 byte pages defined by
+ *		a "pages valid" register and switched via a "page select"
+ *		register as explained in below diagram.
+ *	c) 256 bytes are mapped at a time. 'Lower page 00h' is the first 128
+ *	        bytes of address space, and always references the same
+ *	        location, independent of the page select register.
+ *	        All mapped pages are mapped into the upper 128 bytes
+ *	        (offset 128-255) of the i2c address.
+ *	d) Devices with one I2C address (eg QSFP) use I2C address 0x50
+ *		(A0h in the spec), and map all pages in the upper 128 bytes
+ *		of that address.
+ *	e) Devices with two I2C addresses (eg SFP) have 256 bytes of data
+ *		at I2C address 0x50, and 256 bytes of data at I2C address
+ *		0x51 (A2h in the spec).  Page selection and paged access
+ *		only apply to this second I2C address (0x51).
+ *	e) The address space is presented, by the driver, as a linear
+ *	        address space.  For devices with one I2C client at address
+ *	        0x50 (eg QSFP), offset 0-127 are in the lower
+ *	        half of address 50/A0h/client[0].  Offset 128-255 are in
+ *	        page 0, 256-383 are page 1, etc.  More generally, offset
+ *	        'n' resides in page (n/128)-1.  ('page -1' is the lower
+ *	        half, offset 0-127).
+ *	f) For devices with two I2C clients at address 0x50 and 0x51 (eg SFP),
+ *		the address space places offset 0-127 in the lower
+ *	        half of 50/A0/client[0], offset 128-255 in the upper
+ *	        half.  Offset 256-383 is in the lower half of 51/A2/client[1].
+ *	        Offset 384-511 is in page 0, in the upper half of 51/A2/...
+ *	        Offset 512-639 is in page 1, in the upper half of 51/A2/...
+ *	        Offset 'n' is in page (n/128)-3 (for n > 383)
+ *
+ *	                    One I2c addressed (eg QSFP) Memory Map
+ *
+ *	                    2-Wire Serial Address: 1010000x
+ *
+ *	                    Lower Page 00h (128 bytes)
+ *	                    =====================
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |Page Select Byte(127)|
+ *	                    =====================
+ *	                              |
+ *	                              |
+ *	                              |
+ *	                              |
+ *	                              V
+ *	     ------------------------------------------------------------
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    |                 |                  |                       |
+ *	    V                 V                  V                       V
+ *	 ------------   --------------      ---------------     --------------
+ *	|            | |              |    |               |   |              |
+ *	|   Upper    | |     Upper    |    |     Upper     |   |    Upper     |
+ *	|  Page 00h  | |    Page 01h  |    |    Page 02h   |   |   Page 03h   |
+ *	|            | |   (Optional) |    |   (Optional)  |   |  (Optional   |
+ *	|            | |              |    |               |   |   for Cable  |
+ *	|            | |              |    |               |   |  Assemblies) |
+ *	|    ID      | |     AST      |    |      User     |   |              |
+ *	|  Fields    | |    Table     |    |   EEPROM Data |   |              |
+ *	|            | |              |    |               |   |              |
+ *	|            | |              |    |               |   |              |
+ *	|            | |              |    |               |   |              |
+ *	 ------------   --------------      ---------------     --------------
+ *
+ * The SFF 8436 (QSFP) spec only defines the 4 pages described above.
+ * In anticipation of future applications and devices, this driver
+ * supports access to the full architected range, 256 pages.
+ *
+ **/
+
+/* #define DEBUG 1 */
+
+#undef EEPROM_CLASS
+#ifdef CONFIG_EEPROM_CLASS
+#define EEPROM_CLASS
+#endif
+#ifdef CONFIG_EEPROM_CLASS_MODULE
+#define EEPROM_CLASS
+#endif
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+
+#ifdef EEPROM_CLASS
+#include <linux/eeprom_class.h>
+#endif
+
+#include <linux/types.h>
+
+/* The maximum length of a port name */
+#define MAX_PORT_NAME_LEN 20
+
+struct optoe_platform_data {
+	u32		byte_len;		/* size (sum of all addr) */
+	u16		page_size;		/* for writes */
+	u8		flags;
+	void		*dummy1;		/* backward compatibility */
+	void		*dummy2;		/* backward compatibility */
+
+#ifdef EEPROM_CLASS
+	struct eeprom_platform_data *eeprom_data;
+#endif
+	char port_name[MAX_PORT_NAME_LEN];
+};
+
+/* fundamental unit of addressing for EEPROM */
+#define OPTOE_PAGE_SIZE 128
+/*
+ * Single address devices (eg QSFP) have 256 pages, plus the unpaged
+ * low 128 bytes.  If the device does not support paging, it is
+ * only 2 'pages' long.
+ */
+#define OPTOE_ARCH_PAGES 256
+#define ONE_ADDR_EEPROM_SIZE ((1 + OPTOE_ARCH_PAGES) * OPTOE_PAGE_SIZE)
+#define ONE_ADDR_EEPROM_UNPAGED_SIZE (2 * OPTOE_PAGE_SIZE)
+/*
+ * Dual address devices (eg SFP) have 256 pages, plus the unpaged
+ * low 128 bytes, plus 256 bytes at 0x50.  If the device does not
+ * support paging, it is 4 'pages' long.
+ */
+#define TWO_ADDR_EEPROM_SIZE ((3 + OPTOE_ARCH_PAGES) * OPTOE_PAGE_SIZE)
+#define TWO_ADDR_EEPROM_UNPAGED_SIZE (4 * OPTOE_PAGE_SIZE)
+#define TWO_ADDR_NO_0X51_SIZE (2 * OPTOE_PAGE_SIZE)
+
+/* a few constants to find our way around the EEPROM */
+#define OPTOE_PAGE_SELECT_REG   0x7F
+#define ONE_ADDR_PAGEABLE_REG 0x02
+#define ONE_ADDR_NOT_PAGEABLE (1<<2)
+#define TWO_ADDR_PAGEABLE_REG 0x40
+#define TWO_ADDR_PAGEABLE (1<<4)
+#define TWO_ADDR_0X51_REG 92
+#define TWO_ADDR_0X51_SUPP (1<<6)
+#define OPTOE_ID_REG 0
+#define OPTOE_READ_OP 0
+#define OPTOE_WRITE_OP 1
+#define OPTOE_EOF 0  /* used for access beyond end of device */
+
+struct optoe_data {
+	struct optoe_platform_data chip;
+	int use_smbus;
+	char port_name[MAX_PORT_NAME_LEN];
+
+	/*
+	 * Lock protects against activities from other Linux tasks,
+	 * but not from changes by other I2C masters.
+	 */
+	struct mutex lock;
+	struct bin_attribute bin;
+	struct attribute_group attr_group;
+
+	u8 *writebuf;
+	unsigned int write_max;
+
+	unsigned int num_addresses;
+
+#ifdef EEPROM_CLASS
+	struct eeprom_device *eeprom_dev;
+#endif
+
+	/* dev_class: ONE_ADDR (QSFP) or TWO_ADDR (SFP) */
+	int dev_class;
+
+	struct i2c_client *client[];
+};
+
+
+/*
+ * This parameter is to help this driver avoid blocking other drivers out
+ * of I2C for potentially troublesome amounts of time. With a 100 kHz I2C
+ * clock, one 256 byte read takes about 1/43 second which is excessive;
+ * but the 1/170 second it takes at 400 kHz may be quite reasonable; and
+ * at 1 MHz (Fm+) a 1/430 second delay could easily be invisible.
+ *
+ * This value is forced to be a power of two so that writes align on pages.
+ */
+static unsigned int io_limit = OPTOE_PAGE_SIZE;
+
+/*
+ * specs often allow 5 msec for a page write, sometimes 20 msec;
+ * it's important to recover from write timeouts.
+ */
+static unsigned int write_timeout = 25;
+
+/*
+ * flags to distinguish one-address (QSFP family) from two-address (SFP family)
+ * If the family is not known, figure it out when the device is accessed
+ */
+#define ONE_ADDR 1
+#define TWO_ADDR 2
+
+static const struct i2c_device_id optoe_ids[] = {
+	{ "optoe1", ONE_ADDR },
+	{ "optoe2", TWO_ADDR },
+	{ "sff8436", ONE_ADDR },
+	{ "24c04", TWO_ADDR },
+	{ /* END OF LIST */ }
+};
+MODULE_DEVICE_TABLE(i2c, optoe_ids);
+
+/*-------------------------------------------------------------------------*/
+/*
+ * This routine computes the addressing information to be used for
+ * a given r/w request.
+ *
+ * Task is to calculate the client (0 = i2c addr 50, 1 = i2c addr 51),
+ * the page, and the offset.
+ *
+ * Handles both single address (eg QSFP) and two address (eg SFP).
+ *     For SFP, offset 0-255 are on client[0], >255 is on client[1]
+ *     Offset 256-383 are on the lower half of client[1]
+ *     Pages are accessible on the upper half of client[1].
+ *     Offset >383 are in 128 byte pages mapped into the upper half
+ *
+ *     For QSFP, all offsets are on client[0]
+ *     offset 0-127 are on the lower half of client[0] (no paging)
+ *     Pages are accessible on the upper half of client[1].
+ *     Offset >127 are in 128 byte pages mapped into the upper half
+ *
+ *     Callers must not read/write beyond the end of a client or a page
+ *     without recomputing the client/page.  Hence offset (within page)
+ *     plus length must be less than or equal to 128.  (Note that this
+ *     routine does not have access to the length of the call, hence
+ *     cannot do the validity check.)
+ *
+ * Offset within Lower Page 00h and Upper Page 00h are not recomputed
+ */
+
+static uint8_t optoe_translate_offset(struct optoe_data *optoe,
+		loff_t *offset, struct i2c_client **client)
+{
+	unsigned int page = 0;
+
+	*client = optoe->client[0];
+
+	/* if SFP style, offset > 255, shift to i2c addr 0x51 */
+	if (optoe->dev_class == TWO_ADDR) {
+		if (*offset > 255) {
+			/* like QSFP, but shifted to client[1] */
+			*client = optoe->client[1];
+			*offset -= 256;
+		}
+	}
+
+	/*
+	 * if offset is in the range 0-128...
+	 * page doesn't matter (using lower half), return 0.
+	 * offset is already correct (don't add 128 to get to paged area)
+	 */
+	if (*offset < OPTOE_PAGE_SIZE)
+		return page;
+
+	/* note, page will always be positive since *offset >= 128 */
+	page = (*offset >> 7)-1;
+	/* 0x80 places the offset in the top half, offset is last 7 bits */
+	*offset = OPTOE_PAGE_SIZE + (*offset & 0x7f);
+
+	return page;  /* note also returning client and offset */
+}
+
+static ssize_t optoe_eeprom_read(struct optoe_data *optoe,
+		    struct i2c_client *client,
+		    char *buf, unsigned int offset, size_t count)
+{
+	struct i2c_msg msg[2];
+	u8 msgbuf[2];
+	unsigned long timeout, read_time;
+	int status, i;
+
+	memset(msg, 0, sizeof(msg));
+
+	switch (optoe->use_smbus) {
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		/*smaller eeproms can work given some SMBus extension calls */
+		if (count > I2C_SMBUS_BLOCK_MAX)
+			count = I2C_SMBUS_BLOCK_MAX;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		/* Check for odd length transaction */
+		count = (count == 1) ? 1 : 2;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		count = 1;
+		break;
+	default:
+		/*
+		 * When we have a better choice than SMBus calls, use a
+		 * combined I2C message. Write address; then read up to
+		 * io_limit data bytes.  msgbuf is u8 and will cast to our
+		 * needs.
+		 */
+		i = 0;
+		msgbuf[i++] = offset;
+
+		msg[0].addr = client->addr;
+		msg[0].buf = msgbuf;
+		msg[0].len = i;
+
+		msg[1].addr = client->addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].buf = buf;
+		msg[1].len = count;
+	}
+
+	/*
+	 * Reads fail if the previous write didn't complete yet. We may
+	 * loop a few times until this one succeeds, waiting at least
+	 * long enough for one entire page write to work.
+	 */
+	timeout = jiffies + msecs_to_jiffies(write_timeout);
+	do {
+		read_time = jiffies;
+
+		switch (optoe->use_smbus) {
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			status = i2c_smbus_read_i2c_block_data(client, offset,
+					count, buf);
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			status = i2c_smbus_read_word_data(client, offset);
+			if (status >= 0) {
+				buf[0] = status & 0xff;
+				if (count == 2)
+					buf[1] = status >> 8;
+				status = count;
+			}
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			status = i2c_smbus_read_byte_data(client, offset);
+			if (status >= 0) {
+				buf[0] = status;
+				status = count;
+			}
+			break;
+		default:
+			status = i2c_transfer(client->adapter, msg, 2);
+			if (status == 2)
+				status = count;
+		}
+
+		dev_dbg(&client->dev, "eeprom read %zu@%d --> %d (%ld)\n",
+				count, offset, status, jiffies);
+
+		if (status == count)  /* happy path */
+			return count;
+
+		if (status == -ENXIO) /* no module present */
+			return status;
+
+		/* REVISIT: at HZ=100, this is sloooow */
+		usleep_range(1000, 2000);
+	} while (time_before(read_time, timeout));
+
+	return -ETIMEDOUT;
+}
+
+static ssize_t optoe_eeprom_write(struct optoe_data *optoe,
+				struct i2c_client *client,
+				const char *buf,
+				unsigned int offset, size_t count)
+{
+	struct i2c_msg msg;
+	ssize_t status;
+	unsigned long timeout, write_time;
+	unsigned int next_page_start;
+	int i = 0;
+
+	/* write max is at most a page
+	 * (In this driver, write_max is actually one byte!)
+	 */
+	if (count > optoe->write_max)
+		count = optoe->write_max;
+
+	/* shorten count if necessary to avoid crossing page boundary */
+	next_page_start = roundup(offset + 1, OPTOE_PAGE_SIZE);
+	if (offset + count > next_page_start)
+		count = next_page_start - offset;
+
+	switch (optoe->use_smbus) {
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		/*smaller eeproms can work given some SMBus extension calls */
+		if (count > I2C_SMBUS_BLOCK_MAX)
+			count = I2C_SMBUS_BLOCK_MAX;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		/* Check for odd length transaction */
+		count = (count == 1) ? 1 : 2;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		count = 1;
+		break;
+	default:
+		/* If we'll use I2C calls for I/O, set up the message */
+		msg.addr = client->addr;
+		msg.flags = 0;
+
+		/* msg.buf is u8 and casts will mask the values */
+		msg.buf = optoe->writebuf;
+
+		msg.buf[i++] = offset;
+		memcpy(&msg.buf[i], buf, count);
+		msg.len = i + count;
+		break;
+	}
+
+	/*
+	 * Reads fail if the previous write didn't complete yet. We may
+	 * loop a few times until this one succeeds, waiting at least
+	 * long enough for one entire page write to work.
+	 */
+	timeout = jiffies + msecs_to_jiffies(write_timeout);
+	do {
+		write_time = jiffies;
+
+		switch (optoe->use_smbus) {
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			status = i2c_smbus_write_i2c_block_data(client,
+						offset, count, buf);
+			if (status == 0)
+				status = count;
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			if (count == 2) {
+				status = i2c_smbus_write_word_data(client,
+					offset, (u16)((buf[0])|(buf[1] << 8)));
+			} else {
+				/* count = 1 */
+				status = i2c_smbus_write_byte_data(client,
+					offset, buf[0]);
+			}
+			if (status == 0)
+				status = count;
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			status = i2c_smbus_write_byte_data(client, offset,
+						buf[0]);
+			if (status == 0)
+				status = count;
+			break;
+		default:
+			status = i2c_transfer(client->adapter, &msg, 1);
+			if (status == 1)
+				status = count;
+			break;
+		}
+
+		dev_dbg(&client->dev, "eeprom write %zu@%d --> %ld (%lu)\n",
+				count, offset, (long int) status, jiffies);
+
+		if (status == count)
+			return count;
+
+		/* REVISIT: at HZ=100, this is sloooow */
+		usleep_range(1000, 2000);
+	} while (time_before(write_time, timeout));
+
+	return -ETIMEDOUT;
+}
+
+
+static ssize_t optoe_eeprom_update_client(struct optoe_data *optoe,
+				char *buf, loff_t off,
+				size_t count, int opcode)
+{
+	struct i2c_client *client;
+	ssize_t retval = 0;
+	uint8_t page = 0;
+	loff_t phy_offset = off;
+	int ret = 0;
+
+	page = optoe_translate_offset(optoe, &phy_offset, &client);
+	dev_dbg(&client->dev,
+		"%s off %lld  page:%d phy_offset:%lld, count:%ld, opcode:%d\n",
+		__func__, off, page, phy_offset, (long int) count, opcode);
+	if (page > 0) {
+		ret = optoe_eeprom_write(optoe, client, &page,
+			OPTOE_PAGE_SELECT_REG, 1);
+		if (ret < 0) {
+			dev_dbg(&client->dev,
+				"Write page register for page %d failed ret:%d!\n",
+					page, ret);
+			return ret;
+		}
+	}
+
+	while (count) {
+		ssize_t	status;
+
+		if (opcode == OPTOE_READ_OP) {
+			status =  optoe_eeprom_read(optoe, client,
+				buf, phy_offset, count);
+		} else {
+			status =  optoe_eeprom_write(optoe, client,
+				buf, phy_offset, count);
+		}
+		if (status <= 0) {
+			if (retval == 0)
+				retval = status;
+			break;
+		}
+		buf += status;
+		phy_offset += status;
+		count -= status;
+		retval += status;
+	}
+
+
+	if (page > 0) {
+		/* return the page register to page 0 (why?) */
+		page = 0;
+		ret = optoe_eeprom_write(optoe, client, &page,
+			OPTOE_PAGE_SELECT_REG, 1);
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"Restore page register to 0 failed:%d!\n", ret);
+			/* error only if nothing has been transferred */
+			if (retval == 0)
+				retval = ret;
+		}
+	}
+	return retval;
+}
+
+/*
+ * Figure out if this access is within the range of supported pages.
+ * Note this is called on every access because we don't know if the
+ * module has been replaced since the last call.
+ * If/when modules support more pages, this is the routine to update
+ * to validate and allow access to additional pages.
+ *
+ * Returns updated len for this access:
+ *     - entire access is legal, original len is returned.
+ *     - access begins legal but is too long, len is truncated to fit.
+ *     - initial offset exceeds supported pages, return OPTOE_EOF (zero)
+ */
+static ssize_t optoe_page_legal(struct optoe_data *optoe,
+		loff_t off, size_t len)
+{
+	struct i2c_client *client = optoe->client[0];
+	u8 regval;
+	int status;
+	size_t maxlen;
+
+	if (off < 0)
+		return -EINVAL;
+	if (optoe->dev_class == TWO_ADDR) {
+		/* SFP case */
+		/* if only using addr 0x50 (first 256 bytes) we're good */
+		if ((off + len) <= TWO_ADDR_NO_0X51_SIZE)
+			return len;
+		/* if offset exceeds possible pages, we're not good */
+		if (off >= TWO_ADDR_EEPROM_SIZE)
+			return OPTOE_EOF;
+		/* in between, are pages supported? */
+		status = optoe_eeprom_read(optoe, client, &regval,
+				TWO_ADDR_PAGEABLE_REG, 1);
+		if (status < 0)
+			return status;  /* error out (no module?) */
+		if (regval & TWO_ADDR_PAGEABLE) {
+			/* Pages supported, trim len to the end of pages */
+			maxlen = TWO_ADDR_EEPROM_SIZE - off;
+		} else {
+			/* pages not supported, trim len to unpaged size */
+			if (off >= TWO_ADDR_EEPROM_UNPAGED_SIZE)
+				return OPTOE_EOF;
+
+			/* will be accessing addr 0x51, is that supported? */
+			/* byte 92, bit 6 implies DDM support, 0x51 support */
+			status = optoe_eeprom_read(optoe, client, &regval,
+						TWO_ADDR_0X51_REG, 1);
+			if (status < 0)
+				return status;
+			if (regval & TWO_ADDR_0X51_SUPP) {
+				/* addr 0x51 is OK */
+				maxlen = TWO_ADDR_EEPROM_UNPAGED_SIZE - off;
+			} else {
+				/* addr 0x51 NOT supported, trim to 256 max */
+				if (off >= TWO_ADDR_NO_0X51_SIZE)
+					return OPTOE_EOF;
+				maxlen = TWO_ADDR_NO_0X51_SIZE - off;
+			}
+		}
+		len = (len > maxlen) ? maxlen : len;
+		dev_dbg(&client->dev,
+			"page_legal, SFP, off %lld len %ld\n",
+			off, (long int) len);
+	} else {
+		/* QSFP case */
+		/* if no pages needed, we're good */
+		if ((off + len) <= ONE_ADDR_EEPROM_UNPAGED_SIZE)
+			return len;
+		/* if offset exceeds possible pages, we're not good */
+		if (off >= ONE_ADDR_EEPROM_SIZE)
+			return OPTOE_EOF;
+		/* in between, are pages supported? */
+		status = optoe_eeprom_read(optoe, client, &regval,
+				ONE_ADDR_PAGEABLE_REG, 1);
+		if (status < 0)
+			return status;  /* error out (no module?) */
+		if (regval & ONE_ADDR_NOT_PAGEABLE) {
+			/* pages not supported, trim len to unpaged size */
+			if (off >= ONE_ADDR_EEPROM_UNPAGED_SIZE)
+				return OPTOE_EOF;
+			maxlen = ONE_ADDR_EEPROM_UNPAGED_SIZE - off;
+		} else {
+			/* Pages supported, trim len to the end of pages */
+			maxlen = ONE_ADDR_EEPROM_SIZE - off;
+		}
+		len = (len > maxlen) ? maxlen : len;
+		dev_dbg(&client->dev,
+			"page_legal, QSFP, off %lld len %ld\n",
+			off, (long int) len);
+	}
+	return len;
+}
+
+static ssize_t optoe_read_write(struct optoe_data *optoe,
+		char *buf, loff_t off, size_t len, int opcode)
+{
+	struct i2c_client *client = optoe->client[0];
+	int chunk;
+	int status = 0;
+	ssize_t retval;
+	size_t pending_len = 0, chunk_len = 0;
+	loff_t chunk_offset = 0, chunk_start_offset = 0;
+	loff_t chunk_end_offset = 0;
+
+	dev_dbg(&client->dev,
+		"%s: off %lld  len:%ld, opcode:%s\n",
+		__func__, off, (long int) len,
+		(opcode == OPTOE_READ_OP) ? "r" : "w");
+	if (unlikely(!len))
+		return len;
+
+	/*
+	 * Read data from chip, protecting against concurrent updates
+	 * from this host, but not from other I2C masters.
+	 */
+	mutex_lock(&optoe->lock);
+
+	/*
+	 * Confirm this access fits within the device suppored addr range
+	 */
+	status = optoe_page_legal(optoe, off, len);
+	if ((status == OPTOE_EOF) || (status < 0)) {
+		mutex_unlock(&optoe->lock);
+		return status;
+	}
+	len = status;
+
+	/*
+	 * For each (128 byte) chunk involved in this request, issue a
+	 * separate call to sff_eeprom_update_client(), to
+	 * ensure that each access recalculates the client/page
+	 * and writes the page register as needed.
+	 * Note that chunk to page mapping is confusing, is different for
+	 * QSFP and SFP, and never needs to be done.  Don't try!
+	 */
+	pending_len = len; /* amount remaining to transfer */
+	retval = 0;  /* amount transferred */
+	for (chunk = off >> 7; chunk <= (off + len - 1) >> 7; chunk++) {
+
+		/*
+		 * Compute the offset and number of bytes to be read/write
+		 *
+		 * 1. start at an offset not equal to 0 (within the chunk)
+		 *    and read/write less than the rest of the chunk
+		 * 2. start at an offset not equal to 0 and read/write the rest
+		 *    of the chunk
+		 * 3. start at offset 0 (within the chunk) and read/write less
+		 *    than entire chunk
+		 * 4. start at offset 0 (within the chunk), and read/write
+		 *    the entire chunk
+		 */
+		chunk_start_offset = chunk * OPTOE_PAGE_SIZE;
+		chunk_end_offset = chunk_start_offset + OPTOE_PAGE_SIZE;
+
+		if (chunk_start_offset < off) {
+			chunk_offset = off;
+			if ((off + pending_len) < chunk_end_offset)
+				chunk_len = pending_len;
+			else
+				chunk_len = chunk_end_offset - off;
+		} else {
+			chunk_offset = chunk_start_offset;
+			if (pending_len < OPTOE_PAGE_SIZE)
+				chunk_len = pending_len;
+			else
+				chunk_len = OPTOE_PAGE_SIZE;
+		}
+
+		dev_dbg(&client->dev,
+			"sff_r/w: off %lld, len %ld, chunk_start_offset %lld, chunk_offset %lld, chunk_len %ld, pending_len %ld\n",
+			off, (long int) len, chunk_start_offset, chunk_offset,
+			(long int) chunk_len, (long int) pending_len);
+
+		/*
+		 * note: chunk_offset is from the start of the EEPROM,
+		 * not the start of the chunk
+		 */
+		status = optoe_eeprom_update_client(optoe, buf,
+				chunk_offset, chunk_len, opcode);
+		if (status != chunk_len) {
+			/* This is another 'no device present' path */
+			dev_dbg(&client->dev,
+			"o_u_c: chunk %d c_offset %lld c_len %ld failed %d!\n",
+			chunk, chunk_offset, (long int) chunk_len, status);
+			if (status > 0)
+				retval += status;
+			if (retval == 0)
+				retval = status;
+			break;
+		}
+		buf += status;
+		pending_len -= status;
+		retval += status;
+	}
+	mutex_unlock(&optoe->lock);
+
+	return retval;
+}
+
+static ssize_t optoe_bin_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj,
+				struct device, kobj));
+	struct optoe_data *optoe = i2c_get_clientdata(client);
+
+	return optoe_read_write(optoe, buf, off, count, OPTOE_READ_OP);
+}
+
+
+static ssize_t optoe_bin_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj,
+				struct device, kobj));
+	struct optoe_data *optoe = i2c_get_clientdata(client);
+
+	return optoe_read_write(optoe, buf, off, count, OPTOE_WRITE_OP);
+}
+
+static int optoe_remove(struct i2c_client *client)
+{
+	struct optoe_data *optoe;
+	int i;
+
+	optoe = i2c_get_clientdata(client);
+	sysfs_remove_group(&client->dev.kobj, &optoe->attr_group);
+	sysfs_remove_bin_file(&client->dev.kobj, &optoe->bin);
+
+	for (i = 1; i < optoe->num_addresses; i++)
+		i2c_unregister_device(optoe->client[i]);
+
+#ifdef EEPROM_CLASS
+	eeprom_device_unregister(optoe->eeprom_dev);
+#endif
+
+	kfree(optoe->writebuf);
+	kfree(optoe);
+	return 0;
+}
+
+static ssize_t show_dev_class(struct device *dev,
+			struct device_attribute *dattr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct optoe_data *optoe = i2c_get_clientdata(client);
+	ssize_t count;
+
+	mutex_lock(&optoe->lock);
+	count = sprintf(buf, "%d\n", optoe->dev_class);
+	mutex_unlock(&optoe->lock);
+
+	return count;
+}
+
+static ssize_t set_dev_class(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct optoe_data *optoe = i2c_get_clientdata(client);
+	int dev_class;
+
+	/*
+	 * dev_class is actually the number of i2c addresses used, thus
+	 * legal values are "1" (QSFP class) and "2" (SFP class)
+	 */
+
+	if (kstrtoint(buf, 0, &dev_class) != 0 ||
+		dev_class < 1 || dev_class > 2)
+		return -EINVAL;
+
+	mutex_lock(&optoe->lock);
+	optoe->dev_class = dev_class;
+	mutex_unlock(&optoe->lock);
+
+	return count;
+}
+
+/*
+ * if using the EEPROM CLASS driver, we don't report a port_name,
+ * the EEPROM CLASS drive handles that.  Hence all this code is
+ * only compiled if we are NOT using the EEPROM CLASS driver.
+ */
+#ifndef EEPROM_CLASS
+
+static ssize_t show_port_name(struct device *dev,
+			struct device_attribute *dattr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct optoe_data *optoe = i2c_get_clientdata(client);
+	ssize_t count;
+
+	mutex_lock(&optoe->lock);
+	count = sprintf(buf, "%s\n", optoe->port_name);
+	mutex_unlock(&optoe->lock);
+
+	return count;
+}
+
+static ssize_t set_port_name(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct optoe_data *optoe = i2c_get_clientdata(client);
+	char port_name[MAX_PORT_NAME_LEN];
+
+	/* no checking, this value is not used except by show_port_name */
+
+	if (sscanf(buf, "%19s", port_name) != 1)
+		return -EINVAL;
+
+	mutex_lock(&optoe->lock);
+	strcpy(optoe->port_name, port_name);
+	mutex_unlock(&optoe->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(port_name,  0644, show_port_name, set_port_name);
+#endif  /* if NOT defined EEPROM_CLASS, the common case */
+
+static DEVICE_ATTR(dev_class,  0644, show_dev_class, set_dev_class);
+
+static struct attribute *optoe_attrs[] = {
+#ifndef EEPROM_CLASS
+	&dev_attr_port_name.attr,
+#endif
+	&dev_attr_dev_class.attr,
+	NULL,
+};
+
+static struct attribute_group optoe_attr_group = {
+	.attrs = optoe_attrs,
+};
+
+static int optoe_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	int use_smbus = 0;
+	struct optoe_platform_data chip;
+	struct optoe_data *optoe;
+	int num_addresses = 0;
+	char port_name[MAX_PORT_NAME_LEN];
+
+	if (client->addr != 0x50) {
+		dev_dbg(&client->dev, "probe, bad i2c addr: 0x%x\n",
+				      client->addr);
+		err = -EINVAL;
+		goto exit;
+	}
+
+	if (client->dev.platform_data) {
+		chip = *(struct optoe_platform_data *)client->dev.platform_data;
+		/* take the port name from the supplied platform data */
+#ifdef EEPROM_CLASS
+		strncpy(port_name, chip.eeprom_data->label, MAX_PORT_NAME_LEN);
+#else
+		memcpy(port_name, chip.port_name, MAX_PORT_NAME_LEN);
+#endif
+		dev_dbg(&client->dev,
+			"probe, chip provided, flags:0x%x; name: %s\n",
+			chip.flags, client->name);
+	} else {
+		if (!id->driver_data) {
+			err = -ENODEV;
+			goto exit;
+		}
+		dev_dbg(&client->dev, "probe, building chip\n");
+		strcpy(port_name, "unitialized");
+		chip.flags = 0;
+#ifdef EEPROM_CLASS
+		chip.eeprom_data = NULL;
+#endif
+	}
+
+	/* Use I2C operations unless we're stuck with SMBus extensions. */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		if (i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {
+			use_smbus = I2C_SMBUS_I2C_BLOCK_DATA;
+		} else if (i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_WORD_DATA)) {
+			use_smbus = I2C_SMBUS_WORD_DATA;
+		} else if (i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_BYTE_DATA)) {
+			use_smbus = I2C_SMBUS_BYTE_DATA;
+		} else {
+			err = -EPFNOSUPPORT;
+			goto exit;
+		}
+	}
+
+
+	/*
+	 * Make room for two i2c clients
+	 */
+	num_addresses = 2;
+
+	optoe = kzalloc(sizeof(struct optoe_data) +
+			num_addresses * sizeof(struct i2c_client *),
+			GFP_KERNEL);
+	if (!optoe) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	mutex_init(&optoe->lock);
+
+	/* determine whether this is a one-address or two-address module */
+	if ((strcmp(client->name, "optoe1") == 0) ||
+	    (strcmp(client->name, "sff8436") == 0)) {
+		/* one-address (eg QSFP) family */
+		optoe->dev_class = ONE_ADDR;
+		chip.byte_len = ONE_ADDR_EEPROM_SIZE;
+		num_addresses = 1;
+	} else if ((strcmp(client->name, "optoe2") == 0) ||
+		   (strcmp(client->name, "24c04") == 0)) {
+		/* SFP family */
+		optoe->dev_class = TWO_ADDR;
+		chip.byte_len = TWO_ADDR_EEPROM_SIZE;
+	} else {     /* those were the only two choices */
+		err = -EINVAL;
+		goto exit;
+	}
+
+	dev_dbg(&client->dev, "dev_class: %d\n", optoe->dev_class);
+	optoe->use_smbus = use_smbus;
+	optoe->chip = chip;
+	optoe->num_addresses = num_addresses;
+	memcpy(optoe->port_name, port_name, MAX_PORT_NAME_LEN);
+
+	/*
+	 * Export the EEPROM bytes through sysfs, since that's convenient.
+	 * By default, only root should see the data (maybe passwords etc)
+	 */
+	sysfs_bin_attr_init(&optoe->bin);
+	optoe->bin.attr.name = "eeprom";
+	optoe->bin.attr.mode = 0444;
+	optoe->bin.read = optoe_bin_read;
+	optoe->bin.size = chip.byte_len;
+
+	if (!use_smbus ||
+			(i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) ||
+			i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_WRITE_WORD_DATA) ||
+			i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+		/*
+		 * NOTE: AN-2079
+		 * Finisar recommends that the host implement 1 byte writes
+		 * only since this module only supports 32 byte page boundaries.
+		 * 2 byte writes are acceptable for PE and Vout changes per
+		 * Application Note AN-2071.
+		 */
+		unsigned int write_max = 1;
+
+		optoe->bin.write = optoe_bin_write;
+		optoe->bin.attr.mode |= 0200;
+
+		if (write_max > io_limit)
+			write_max = io_limit;
+		if (use_smbus && write_max > I2C_SMBUS_BLOCK_MAX)
+			write_max = I2C_SMBUS_BLOCK_MAX;
+		optoe->write_max = write_max;
+
+		/* buffer (data + address at the beginning) */
+		optoe->writebuf = kmalloc(write_max + 2, GFP_KERNEL);
+		if (!optoe->writebuf) {
+			err = -ENOMEM;
+			goto exit_kfree;
+		}
+	} else {
+		dev_warn(&client->dev,
+			"cannot write due to controller restrictions.");
+	}
+
+	optoe->client[0] = client;
+
+	/* SFF-8472 spec requires that the second I2C address be 0x51 */
+	if (num_addresses == 2) {
+		optoe->client[1] = i2c_new_dummy(client->adapter, 0x51);
+		if (!optoe->client[1]) {
+			dev_err(&client->dev, "address 0x51 unavailable\n");
+			err = -EADDRINUSE;
+			goto err_struct;
+		}
+	}
+
+	/* create the sysfs eeprom file */
+	err = sysfs_create_bin_file(&client->dev.kobj, &optoe->bin);
+	if (err)
+		goto err_struct;
+
+	optoe->attr_group = optoe_attr_group;
+
+	err = sysfs_create_group(&client->dev.kobj, &optoe->attr_group);
+	if (err) {
+		dev_err(&client->dev, "failed to create sysfs attribute group.\n");
+		goto err_struct;
+	}
+
+#ifdef EEPROM_CLASS
+	optoe->eeprom_dev = eeprom_device_register(&client->dev,
+							chip.eeprom_data);
+	if (IS_ERR(optoe->eeprom_dev)) {
+		dev_err(&client->dev, "error registering eeprom device.\n");
+		err = PTR_ERR(optoe->eeprom_dev);
+		goto err_sysfs_cleanup;
+	}
+#endif
+
+	i2c_set_clientdata(client, optoe);
+
+	dev_info(&client->dev, "%zu byte %s EEPROM, %s\n",
+		optoe->bin.size, client->name,
+		optoe->bin.write ? "read/write" : "read-only");
+
+	if (use_smbus == I2C_SMBUS_WORD_DATA ||
+	    use_smbus == I2C_SMBUS_BYTE_DATA) {
+		dev_notice(&client->dev,
+			"Falling back to %s reads, performance will suffer\n",
+			use_smbus == I2C_SMBUS_WORD_DATA ? "word" : "byte");
+	}
+
+	return 0;
+
+#ifdef EEPROM_CLASS
+err_sysfs_cleanup:
+	sysfs_remove_group(&client->dev.kobj, &optoe->attr_group);
+	sysfs_remove_bin_file(&client->dev.kobj, &optoe->bin);
+#endif
+
+err_struct:
+	if (num_addresses == 2) {
+		if (optoe->client[1])
+			i2c_unregister_device(optoe->client[1]);
+	}
+
+	kfree(optoe->writebuf);
+exit_kfree:
+	kfree(optoe);
+exit:
+	dev_dbg(&client->dev, "probe error %d\n", err);
+
+	return err;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct i2c_driver optoe_driver = {
+	.driver = {
+		.name = "optoe",
+		.owner = THIS_MODULE,
+	},
+	.probe = optoe_probe,
+	.remove = optoe_remove,
+	.id_table = optoe_ids,
+};
+
+static int __init optoe_init(void)
+{
+
+	if (!io_limit) {
+		pr_err("optoe: io_limit must not be 0!\n");
+		return -EINVAL;
+	}
+
+	io_limit = rounddown_pow_of_two(io_limit);
+	return i2c_add_driver(&optoe_driver);
+}
+module_init(optoe_init);
+
+static void __exit optoe_exit(void)
+{
+	i2c_del_driver(&optoe_driver);
+}
+module_exit(optoe_exit);
+
+MODULE_DESCRIPTION("Driver for optical transceiver (SFP, QSFP, ...) EEPROMs");
+MODULE_AUTHOR("DON BOLLINGER <don@thebollingers.org>");
+MODULE_LICENSE("GPL");
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_baseboard_cpld.c b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_baseboard_cpld.c
new file mode 100644
index 000000000000..1a5527f0d691
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_baseboard_cpld.c
@@ -0,0 +1,409 @@
+/*
+ * seastone2_baseboard_cpld.c - driver for Seastone2 Base Board CPLD
+ * This driver implement sysfs for CPLD register access using LPC bus.
+ * Copyright (C) 2017 Celestica Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/acpi.h>
+#include <linux/io.h>
+#include <linux/dmi.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <uapi/linux/stat.h>
+#include <linux/string.h>
+
+#define DRIVER_NAME "sys_cpld"
+/**
+ * CPLD register address for read and write.
+ */
+#define VERSION_ADDR 0xA100
+#define SCRATCH_ADDR 0xA101
+#define SYS_LED_ADDR 0xA162
+#define THERMAL_ADDR 0xA176
+#define CPLD_REGISTER_SIZE 0x77
+
+struct baseboard_cpld_data {
+    struct mutex       cpld_lock;
+    uint16_t           read_addr;
+};
+
+struct baseboard_cpld_data *cpld_data;
+
+/**
+ * Read the value from scratch register as hex string.
+ * @param  dev     kernel device
+ * @param  devattr kernel device attribute
+ * @param  buf     buffer for get value
+ * @return         Hex string read from scratch register.
+ */
+static ssize_t scratch_show(struct device *dev, struct device_attribute *devattr,
+                char *buf)
+{
+    unsigned char data = 0;
+    mutex_lock(&cpld_data->cpld_lock);
+    data = inb(SCRATCH_ADDR);
+    mutex_unlock(&cpld_data->cpld_lock);
+    return sprintf(buf,"0x%2.2x\n", data);
+}
+
+/**
+ * Set scratch register with specific hex string.
+ * @param  dev     kernel device
+ * @param  devattr kernel device attribute
+ * @param  buf     buffer of set value
+ * @param  count   number of bytes in buffer
+ * @return         number of bytes written, or error code < 0.
+ */
+static ssize_t scratch_store(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    unsigned long data;
+    char *last;
+
+    mutex_lock(&cpld_data->cpld_lock);
+    data = (uint16_t)strtoul(buf,&last,16);
+    if(data == 0 && buf == last){
+        mutex_unlock(&cpld_data->cpld_lock);
+        return -EINVAL;
+    }
+    outb(data, SCRATCH_ADDR);
+    mutex_unlock(&cpld_data->cpld_lock);
+    return count;
+}
+static DEVICE_ATTR_RW(scratch);
+
+
+/* CPLD version attributes */
+static ssize_t version_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // CPLD register is one byte
+    mutex_lock(&cpld_data->cpld_lock);
+    int len = sprintf(buf, "0x%2.2x\n",inb(VERSION_ADDR));
+    mutex_unlock(&cpld_data->cpld_lock);
+    return len;
+}
+static DEVICE_ATTR_RO(version);
+
+
+static ssize_t getreg_store(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    // CPLD register is one byte
+    uint16_t addr;
+    char *last;
+
+    addr = (uint16_t)strtoul(buf,&last,16);
+    if(addr == 0 && buf == last){
+        return -EINVAL;
+    }
+    cpld_data->read_addr = addr;
+    return count;
+}
+
+static ssize_t getreg_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // CPLD register is one byte
+    mutex_lock(&cpld_data->cpld_lock);
+    int len = sprintf(buf, "0x%2.2x\n",inb(cpld_data->read_addr));
+    mutex_unlock(&cpld_data->cpld_lock);
+    return len;
+}
+static DEVICE_ATTR_RW(getreg);
+
+static ssize_t setreg_store(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    // CPLD register is one byte
+    uint16_t addr;
+    uint8_t value;
+    char *tok;
+    char clone[count];
+    char *pclone = clone;
+    char *last;
+
+    strcpy(clone, buf);
+
+    mutex_lock(&cpld_data->cpld_lock);
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        mutex_unlock(&cpld_data->cpld_lock);
+        return -EINVAL;
+    }
+    addr = (uint16_t)strtoul(tok,&last,16);
+    if(addr == 0 && tok == last){
+        mutex_unlock(&cpld_data->cpld_lock);
+        return -EINVAL;
+    }
+
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        mutex_unlock(&cpld_data->cpld_lock);
+        return -EINVAL;
+    }
+    value = (uint8_t)strtoul(tok,&last,16);
+    if(value == 0 && tok == last){
+        mutex_unlock(&cpld_data->cpld_lock);
+        return -EINVAL;
+    }
+
+    outb(value,addr);
+    mutex_unlock(&cpld_data->cpld_lock);
+    return count;
+}
+static DEVICE_ATTR_WO(setreg);
+
+/**
+ * Read all CPLD register in binary mode.
+ * @return number of byte read.
+ */
+static ssize_t dump_read(struct file *filp, struct kobject *kobj,
+                struct bin_attribute *attr, char *buf,
+                loff_t off, size_t count)
+{
+    unsigned long i=0;
+    ssize_t status;
+
+    mutex_lock(&cpld_data->cpld_lock);
+begin:
+    if(i < count){
+        buf[i++] = inb(VERSION_ADDR + off);
+        off++;
+        msleep(1);
+        goto begin;
+    }
+    status = count;
+exit:
+    mutex_unlock(&cpld_data->cpld_lock);
+    return status;
+}
+static BIN_ATTR_RO(dump, CPLD_REGISTER_SIZE);
+
+/**
+ * Show system led status - on/off/1k/4k
+ * @param  dev     kernel device
+ * @param  devattr kernel device attribute
+ * @param  buf     buffer for get value
+ * @return         Hex string read from scratch register.
+ */
+static ssize_t sys_led_show(struct device *dev, struct device_attribute *devattr,
+                char *buf)
+{
+    unsigned char data = 0;
+    mutex_lock(&cpld_data->cpld_lock);
+    data = inb(SYS_LED_ADDR);
+    mutex_unlock(&cpld_data->cpld_lock);
+    data = data & 0x3;
+    return sprintf(buf, "%s\n",
+            data == 0x03 ? "off" : data == 0x02 ? "4k" : data ==0x01 ? "1k": "on");
+}
+
+/**
+ * Set the status of system led - on/off/1k/4k
+ * @param  dev     kernel device
+ * @param  devattr kernel device attribute
+ * @param  buf     buffer of set value
+ * @param  count   number of bytes in buffer
+ * @return         number of bytes written, or error code < 0.
+ */
+static ssize_t sys_led_store(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    unsigned char led_status,data;
+    if(sysfs_streq(buf, "off")){
+        led_status = 0x03;
+    }else if(sysfs_streq(buf, "4k")){
+        led_status = 0x02;
+    }else if(sysfs_streq(buf, "1k")){
+        led_status = 0x01;
+    }else if(sysfs_streq(buf, "on")){
+        led_status = 0x00;
+    }else{
+        count = -EINVAL;
+        return count;
+    }
+    mutex_lock(&cpld_data->cpld_lock);
+    data = inb(SYS_LED_ADDR);
+    data = data & ~(0x3);
+    data = data | led_status;
+    outb(data, SYS_LED_ADDR);
+    mutex_unlock(&cpld_data->cpld_lock);
+    return count;
+}
+static DEVICE_ATTR_RW(sys_led);
+
+/**
+ * Show system led color - both/green/yellow/none
+ * @param  dev     kernel device
+ * @param  devattr kernel device attribute
+ * @param  buf     buffer for get value
+ * @return         Hex string read from scratch register.
+ */
+static ssize_t sys_led_color_show(struct device *dev, struct device_attribute *devattr,
+                char *buf)
+{
+    unsigned char data = 0;
+    mutex_lock(&cpld_data->cpld_lock);
+    data = inb(SYS_LED_ADDR);
+    mutex_unlock(&cpld_data->cpld_lock);
+    data = (data >> 4) & 0x3;
+    return sprintf(buf, "%s\n",
+            data == 0x03 ? "off" : data == 0x02 ? "yellow" : data ==0x01 ? "green": "both");
+}
+
+/**
+ * Set the color of system led - both/green/yellow/none
+ * @param  dev     kernel device
+ * @param  devattr kernel device attribute
+ * @param  buf     buffer of set value
+ * @param  count   number of bytes in buffer
+ * @return         number of bytes written, or error code < 0.
+ */
+static ssize_t sys_led_color_store(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    unsigned char led_status,data;
+    if(sysfs_streq(buf, "off")){
+        led_status = 0x03;
+    }else if(sysfs_streq(buf, "yellow")){
+        led_status = 0x02;
+    }else if(sysfs_streq(buf, "green")){
+        led_status = 0x01;
+    }else if(sysfs_streq(buf, "both")){
+        led_status = 0x00;
+    }else{
+        count = -EINVAL;
+        return count;
+    }
+    mutex_lock(&cpld_data->cpld_lock);
+    data = inb(SYS_LED_ADDR);
+    data = data & ~( 0x3 << 4);
+    data = data | (led_status << 4);
+    outb(data, SYS_LED_ADDR);
+    mutex_unlock(&cpld_data->cpld_lock);
+    return count;
+}
+static DEVICE_ATTR_RW(sys_led_color);
+
+static struct attribute *baseboard_cpld_attrs[] = {
+    &dev_attr_version.attr,
+    &dev_attr_scratch.attr,
+    &dev_attr_getreg.attr,
+    &dev_attr_setreg.attr,
+    &dev_attr_sys_led.attr,
+    &dev_attr_sys_led_color.attr,
+    NULL,
+};
+
+static struct bin_attribute *baseboard_cpld_bin_attrs[] = {
+    &bin_attr_dump,
+    NULL,
+};
+
+static struct attribute_group baseboard_cpld_attrs_grp = {
+    .attrs = baseboard_cpld_attrs,
+    .bin_attrs = baseboard_cpld_bin_attrs,
+};
+
+static struct resource baseboard_cpld_resources[] = {
+    {
+        .start  = 0xA100,
+        .end    = 0xA1FF,
+        .flags  = IORESOURCE_IO,
+    },
+};
+
+static void baseboard_cpld_dev_release( struct device * dev)
+{
+    return;
+}
+
+static struct platform_device baseboard_cpld_dev = {
+    .name           = DRIVER_NAME,
+    .id             = -1,
+    .num_resources  = ARRAY_SIZE(baseboard_cpld_resources),
+    .resource       = baseboard_cpld_resources,
+    .dev = {
+        .release = baseboard_cpld_dev_release,
+    }
+};
+
+static int baseboard_cpld_drv_probe(struct platform_device *pdev)
+{
+    struct resource *res;
+    int ret =0;
+    int portid_count;
+
+    cpld_data = devm_kzalloc(&pdev->dev, sizeof(struct baseboard_cpld_data),
+        GFP_KERNEL);
+    if (!cpld_data)
+        return -ENOMEM;
+
+    mutex_init(&cpld_data->cpld_lock);
+
+    cpld_data->read_addr = VERSION_ADDR;
+
+    res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+    if (unlikely(!res)) {
+        printk(KERN_ERR "Specified Resource Not Available...\n");
+        return -1;
+    }
+
+    ret = sysfs_create_group(&pdev->dev.kobj, &baseboard_cpld_attrs_grp);
+    if (ret) {
+        printk(KERN_ERR "Cannot create sysfs for baseboard CPLD\n");
+    }
+    return 0;
+}
+
+static int baseboard_cpld_drv_remove(struct platform_device *pdev)
+{
+    sysfs_remove_group(&pdev->dev.kobj, &baseboard_cpld_attrs_grp);
+    return 0;
+}
+
+static struct platform_driver baseboard_cpld_drv = {
+    .probe  = baseboard_cpld_drv_probe,
+    .remove = __exit_p(baseboard_cpld_drv_remove),
+    .driver = {
+        .name   = DRIVER_NAME,
+    },
+};
+
+int baseboard_cpld_init(void)
+{
+    // Register platform device and platform driver
+    platform_device_register(&baseboard_cpld_dev);
+    platform_driver_register(&baseboard_cpld_drv);
+    return 0;
+}
+
+void baseboard_cpld_exit(void)
+{
+    // Unregister platform device and platform driver
+    platform_driver_unregister(&baseboard_cpld_drv);
+    platform_device_unregister(&baseboard_cpld_dev);
+}
+
+module_init(baseboard_cpld_init);
+module_exit(baseboard_cpld_exit);
+
+MODULE_AUTHOR("Pradchaya Phucharoen  <pphuchar@celestica.com>");
+MODULE_DESCRIPTION("Celestica Seastone2/Questone2 Baseboard CPLD Driver");
+MODULE_LICENSE("GPL");
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_switchboard.c b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_switchboard.c
new file mode 100644
index 000000000000..f10b5ba7b92d
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/questone2a_switchboard.c
@@ -0,0 +1,2148 @@
+/*
+ * seastone_switchboard.c - driver for seastone2/questone2 Switch board FPGA/CPLD.
+ *
+ * Author: Pradchaya Phucharoen
+ *
+ * Copyright (C) 2017 Celestica Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ *   /
+ *   \--sys
+ *       \--devices
+ *            \--platform
+ *                \--seastone2
+ *                    |--FPGA
+ *                    |--CPLD1
+ *                    |--CPLD2
+ *                    \--SFF
+ *                        |--QSFP[1..32]
+ *                        \--SFP[1..2]
+ *
+ */
+
+#ifndef TEST_MODE
+#define MOD_VERSION "2.0.0"
+#else
+#define MOD_VERSION "TEST"
+#endif
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/stddef.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/acpi.h>
+#include <linux/io.h>
+#include <linux/dmi.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/kobject.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <uapi/linux/stat.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/jiffies.h>
+
+
+
+static int  majorNumber;
+#ifdef SEASTONE2
+#define CLASS_NAME "seastone2_fpga"
+#define DRIVER_NAME "seastone2"
+#define FPGA_PCI_NAME "Seastone2_fpga_pci"
+#endif
+#ifdef QUESTONE2
+#define CLASS_NAME "questone2_fpga"
+#define DRIVER_NAME "questone2"
+#define FPGA_PCI_NAME "questone2_fpga_pci"
+#endif
+#ifdef QUESTONE2A
+#define CLASS_NAME "questone2a_fpga"
+#define DRIVER_NAME "questone2a"
+#define FPGA_PCI_NAME "questone2a_fpga_pci"
+#endif
+#define DEVICE_NAME "fwupgrade"
+
+
+static int smbus_access(struct i2c_adapter *adapter, u16 addr,
+              unsigned short flags, char rw, u8 cmd,
+              int size, union i2c_smbus_data *data);
+
+static int fpga_i2c_access(struct i2c_adapter *adapter, u16 addr,
+              unsigned short flags, char rw, u8 cmd,
+              int size, union i2c_smbus_data *data);
+
+static int fpgafw_init(void);
+static void fpgafw_exit(void);
+
+
+/*
+========================================
+FPGA PCIe BAR 0 Registers
+========================================
+Misc Control    0x00000000  0x000000FF.
+I2C_CH1         0x00000100 - 0x00000110
+I2C_CH2         0x00000200 - 0x00000210.
+I2C_CH3         0x00000300 - 0x00000310.
+I2C_CH4         0x00000400 - 0x00000410.
+I2C_CH5         0x00000500 - 0x00000510.
+I2C_CH6         0x00000600 - 0x00000610.
+I2C_CH7         0x00000700 - 0x00000710.
+I2C_CH8         0x00000800 - 0x00000810.
+I2C_CH9         0x00000900 - 0x00000910.
+I2C_CH10        0x00000A00 - 0x00000A10.
+SPI Master      0x00001200 - 0x00001300.
+PORT XCVR       0x00004000 - 0x00004FFF.
+*/
+
+/* MISC       */
+#define FPGA_VERSION            0x0000
+#define FPGA_VERSION_MJ_MSK     0xff00
+#define FPGA_VERSION_MN_MSK     0x00ff
+#define FPGA_SCRATCH            0x0004
+#define FPGA_BROAD_TYPE         0x0008
+#define FPGA_BROAD_REV_MSK      0x0038
+#define FPGA_BROAD_ID_MSK       0x0007
+#define FPGA_PLL_STATUS         0x0014
+#define BMC_I2C_SCRATCH         0x0020
+#define FPGA_SLAVE_CPLD_REST    0x0030
+#define FPGA_PERIPH_RESET_CTRL  0x0034
+#define FPGA_INT_STATUS         0x0040
+#define FPGA_INT_SRC_STATUS     0x0044
+#define FPGA_INT_FLAG           0x0048
+#define FPGA_INT_MASK           0x004c
+#define FPGA_MISC_CTRL          0x0050
+#define FPGA_MISC_STATUS        0x0054
+#define FPGA_AVS_VID_STATUS     0x0068
+#define FPGA_FEATURE_CARD_GPIO  0x0070
+#define FPGA_PORT_XCVR_READY    0x000c
+
+/* I2C_MASTER BASE ADDR */
+#define I2C_MASTER_FREQ_1           0x0100
+#define I2C_MASTER_CTRL_1           0x0104
+#define I2C_MASTER_STATUS_1         0x0108
+#define I2C_MASTER_DATA_1           0x010c
+#define I2C_MASTER_PORT_ID_1        0x0110
+#define I2C_MASTER_CH_1             1
+#define I2C_MASTER_CH_2             2
+#define I2C_MASTER_CH_3             3
+#define I2C_MASTER_CH_4             4
+#define I2C_MASTER_CH_5             5
+#define I2C_MASTER_CH_6             6
+#define I2C_MASTER_CH_7             7
+#define I2C_MASTER_CH_8             8
+#define I2C_MASTER_CH_9             9
+#define I2C_MASTER_CH_10            10
+#define I2C_MASTER_CH_TOTAL I2C_MASTER_CH_10
+
+/* SPI_MASTER */
+#define SPI_MASTER_WR_EN            0x1200 /* one bit */
+#define SPI_MASTER_WR_DATA          0x1204 /* 32 bits */
+#define SPI_MASTER_CHK_ID           0x1208 /* one bit */
+#define SPI_MASTER_VERIFY           0x120c /* one bit */
+#define SPI_MASTER_STATUS           0x1210 /* 15 bits */
+#define SPI_MASTER_MODULE_RST       0x1214 /* one bit */
+
+/* FPGA FRONT PANEL PORT MGMT */
+#define SFF_PORT_CTRL_BASE          0x4000
+#define SFF_PORT_STATUS_BASE        0x4004
+#define SFF_PORT_INT_STATUS_BASE    0x4008
+#define SFF_PORT_INT_MASK_BASE      0x400c
+
+#define PORT_XCVR_REGISTER_SIZE     0x1000
+
+/* PORT CTRL REGISTER
+[31:7]  RSVD
+[6]     LPMOD   6
+[5]     RSVD
+[4]     RST     4
+[3:1]   RSVD
+[0]     TXDIS   0
+*/
+#define CTRL_LPMOD   6
+#define CTRL_RST     4
+#define CTRL_TXDIS   0
+
+/* PORT STATUS REGISTER
+[31:6]  RSVD
+[5]     IRQ         5
+[4]     PRESENT     4
+[3]     RSVD
+[2]     TXFAULT     2
+[1]     RXLOS       1
+[0]     MODABS      0
+*/
+#define STAT_IRQ         5
+#define STAT_PRESENT     4
+#define STAT_TXFAULT     2
+#define STAT_RXLOS       1
+#define STAT_MODABS      0
+
+/* PORT INTRPT REGISTER
+[31:6]  RSVD
+[5]     INT_N       5
+[4]     PRESENT     4
+[3]     RSVD
+[2]     RSVD
+[1]     RXLOS       1
+[0]     MODABS      0
+*/
+#define INTR_INT_N      5
+#define INTR_PRESENT    4
+#define INTR_TXFAULT    2
+#define INTR_RXLOS      1
+#define INTR_MODABS     0
+
+/* PORT INT MASK REGISTER
+[31:6]  RSVD
+[5]     INT_N       5
+[4]     PRESENT     4
+[3]     RSVD
+[2]     RSVD
+[1]     RXLOS_INT   1
+[0]     MODABS      0
+*/
+#define MASK_INT_N      5
+#define MASK_PRESENT    4
+#define MASK_TXFAULT    2
+#define MASK_RXLOS      1
+#define MASK_MODABS     0
+
+enum {
+    I2C_SR_BIT_RXAK = 0,
+    I2C_SR_BIT_MIF,
+    I2C_SR_BIT_SRW,
+    I2C_SR_BIT_BCSTM,
+    I2C_SR_BIT_MAL,
+    I2C_SR_BIT_MBB,
+    I2C_SR_BIT_MAAS,
+    I2C_SR_BIT_MCF
+};
+
+enum {
+    I2C_CR_BIT_BCST = 0,
+    I2C_CR_BIT_RSTA = 2,
+    I2C_CR_BIT_TXAK,
+    I2C_CR_BIT_MTX,
+    I2C_CR_BIT_MSTA,
+    I2C_CR_BIT_MIEN,
+    I2C_CR_BIT_MEN,
+};
+
+/**
+ *
+ * The function is i2c algorithm implement to allow master access to
+ * correct endpoint devices trough the PCA9548 switch devices.
+ *
+ *  FPGA I2C Master [mutex resource]
+ *              |
+ *              |
+ *    ---------------------------
+ *    |        PCA9548(s)       |
+ *    ---1--2--3--4--5--6--7--8--
+ *       |  |  |  |  |  |  |  |
+ *   EEPROM      ...          EEPROM
+ *
+ */
+
+
+#ifdef SEASTONE2
+#define VIRTUAL_I2C_QSFP_PORT           32
+#define VIRTUAL_I2C_SFP_PORT            1
+#define VIRTUAL_I2C_CPLD_PORT           1
+#define VIRTUAL_I2C_POWER_CHIP_PORT     1
+#define VIRTUAL_I2C_CPLD_B_PORT         1
+#define VIRTUAL_I2C_PSU                 1
+#define VIRTUAL_I2C_FAN_TRAY            4
+#define VIRTUAL_I2C_POWER_MON           1
+#define VIRTUAL_I2C_LM75                1
+
+#define VIRTUAL_I2C_PORT_LENGTH \
+            VIRTUAL_I2C_SFP_PORT+VIRTUAL_I2C_QSFP_PORT+VIRTUAL_I2C_POWER_CHIP_PORT+VIRTUAL_I2C_CPLD_PORT+VIRTUAL_I2C_CPLD_B_PORT+VIRTUAL_I2C_PSU+VIRTUAL_I2C_FAN_TRAY+VIRTUAL_I2C_POWER_MON+VIRTUAL_I2C_LM75
+
+#define SFF_PORT_TOTAL    VIRTUAL_I2C_QSFP_PORT+VIRTUAL_I2C_SFP_PORT
+#else
+#define VIRTUAL_I2C_SFP_PORT            48
+#define VIRTUAL_I2C_QSFP_PORT           8
+#define VIRTUAL_I2C_CPLD_PORT           1
+#define VIRTUAL_I2C_POWER_CHIP_PORT     1
+#define VIRTUAL_I2C_CPLD_B_PORT         1
+#define VIRTUAL_I2C_PSU                 1
+#define VIRTUAL_I2C_FAN_TRAY            4
+#define VIRTUAL_I2C_POWER_MON           1
+#define VIRTUAL_I2C_LM75                1
+
+#define VIRTUAL_I2C_PORT_LENGTH \
+            VIRTUAL_I2C_SFP_PORT+VIRTUAL_I2C_QSFP_PORT+VIRTUAL_I2C_POWER_CHIP_PORT+VIRTUAL_I2C_CPLD_PORT+VIRTUAL_I2C_CPLD_B_PORT+VIRTUAL_I2C_PSU+VIRTUAL_I2C_FAN_TRAY+VIRTUAL_I2C_POWER_MON+VIRTUAL_I2C_LM75
+
+#define SFF_PORT_TOTAL    VIRTUAL_I2C_QSFP_PORT+VIRTUAL_I2C_SFP_PORT
+#endif
+
+#define VIRTUAL_I2C_CPLD_INDEX SFF_PORT_TOTAL
+
+#define VIRTUAL_I2C_BUS_OFFSET  2
+#define CPLD1_SLAVE_ADDR        0x30
+#define CPLD2_SLAVE_ADDR        0x31
+
+static struct class*  fpgafwclass  = NULL; ///< The device-driver class struct pointer
+static struct device* fpgafwdev = NULL; ///< The device-driver device struct pointer
+
+#define PCI_VENDOR_ID_TEST 0x1af4
+
+#ifndef PCI_VENDOR_ID_XILINX
+#define PCI_VENDOR_ID_XILINX 0x10EE
+#endif
+
+#define FPGA_PCIE_DEVICE_ID 0x7021
+#define TEST_PCIE_DEVICE_ID 0x1110
+
+
+#ifdef DEBUG_KERN
+#define info(fmt,args...)  printk(KERN_INFO "line %3d : "fmt,__LINE__,##args)
+#define check(REG)         printk(KERN_INFO "line %3d : %-8s = %2.2X",__LINE__,#REG,ioread8(REG));
+#else
+#define info(fmt,args...)
+#define check(REG)
+#endif
+
+#define GET_REG_BIT(REG,BIT)   ((ioread8(REG) >> BIT) & 0x01)
+#define SET_REG_BIT_H(REG,BIT) iowrite8(ioread8(REG) |  (0x01 << BIT),REG)
+#define SET_REG_BIT_L(REG,BIT) iowrite8(ioread8(REG) & ~(0x01 << BIT),REG)
+
+static struct mutex fpga_i2c_master_locks[I2C_MASTER_CH_TOTAL];
+/* Store lasted switch address and channel */
+static uint16_t fpga_i2c_lasted_access_port[I2C_MASTER_CH_TOTAL];
+
+enum PORT_TYPE {
+    NONE,
+    QSFP,
+    SFP
+};
+
+struct i2c_switch{
+    unsigned char master_bus;   // I2C bus number
+    unsigned char switch_addr;  // PCA9548 device address, 0xFF if directly connect to a bus.
+    unsigned char channel;      // PCA9548 channel number. If the switch_addr is 0xFF, this value is ignored.
+    enum PORT_TYPE port_type;   // QSFP/SFP tranceiver port type.
+    char calling_name[20];      // Calling name.
+};
+
+struct i2c_dev_data {
+    int portid;
+    struct i2c_switch pca9548;
+};
+
+#ifdef SEASTONE2
+/* PREDEFINED I2C SWITCH DEVICE TOPOLOGY */
+static struct i2c_switch fpga_i2c_bus_dev[] = {
+    /* BUS2 QSFP Exported as virtual bus */
+    {I2C_MASTER_CH_2,0x72,0,QSFP,"QSFP1"}, {I2C_MASTER_CH_2,0x72,1,QSFP,"QSFP2"}, {I2C_MASTER_CH_2,0x72,2,QSFP,"QSFP3"}, {I2C_MASTER_CH_2,0x72,3,QSFP,"QSFP4"},
+    {I2C_MASTER_CH_2,0x72,4,QSFP,"QSFP5"}, {I2C_MASTER_CH_2,0x72,5,QSFP,"QSFP6"}, {I2C_MASTER_CH_2,0x72,6,QSFP,"QSFP7"}, {I2C_MASTER_CH_2,0x72,7,QSFP,"QSFP8"},
+    {I2C_MASTER_CH_2,0x73,0,QSFP,"QSFP9"}, {I2C_MASTER_CH_2,0x73,1,QSFP,"QSFP10"},{I2C_MASTER_CH_2,0x73,2,QSFP,"QSFP11"},{I2C_MASTER_CH_2,0x73,3,QSFP,"QSFP12"},
+    {I2C_MASTER_CH_2,0x73,4,QSFP,"QSFP13"},{I2C_MASTER_CH_2,0x73,5,QSFP,"QSFP14"},{I2C_MASTER_CH_2,0x73,6,QSFP,"QSFP15"},{I2C_MASTER_CH_2,0x73,7,QSFP,"QSFP16"},
+    {I2C_MASTER_CH_2,0x74,0,QSFP,"QSFP17"},{I2C_MASTER_CH_2,0x74,1,QSFP,"QSFP18"},{I2C_MASTER_CH_2,0x74,2,QSFP,"QSFP19"},{I2C_MASTER_CH_2,0x74,3,QSFP,"QSFP20"},
+    {I2C_MASTER_CH_2,0x74,4,QSFP,"QSFP21"},{I2C_MASTER_CH_2,0x74,5,QSFP,"QSFP22"},{I2C_MASTER_CH_2,0x74,6,QSFP,"QSFP23"},{I2C_MASTER_CH_2,0x74,7,QSFP,"QSFP24"},
+    {I2C_MASTER_CH_2,0x75,0,QSFP,"QSFP25"},{I2C_MASTER_CH_2,0x75,1,QSFP,"QSFP26"},{I2C_MASTER_CH_2,0x75,2,QSFP,"QSFP27"},{I2C_MASTER_CH_2,0x75,3,QSFP,"QSFP28"},
+    {I2C_MASTER_CH_2,0x75,4,QSFP,"QSFP29"},{I2C_MASTER_CH_2,0x75,5,QSFP,"QSFP30"},{I2C_MASTER_CH_2,0x75,6,QSFP,"QSFP31"},{I2C_MASTER_CH_2,0x75,7,QSFP,"QSFP32"},
+    /* BUS1 SFP+ Exported as virtual bus */
+    {I2C_MASTER_CH_1,0x72,0,SFP,"SFP1"},{I2C_MASTER_CH_1,0x72,1,SFP,"SFP2"},
+    /* BUS3 CPLD Access via SYSFS */
+    {I2C_MASTER_CH_3,0xFF,0,NONE,"CPLD"},
+    /* BUS5 POWER CHIP Exported as virtual bus */
+    {I2C_MASTER_CH_5,0xFF,0,NONE,"POWER"},
+    /* BUS4 CPLD_B */
+    {I2C_MASTER_CH_4,0xFF,0,NONE,"CPLD_B"},
+    /* BUS6 PSU */
+    {I2C_MASTER_CH_6,0xFF,0,NONE,"PSU"},
+    /* BUS7 FAN */
+    /* Channel 2 is no hardware connected */
+    {I2C_MASTER_CH_7,0x77,0,NONE,"FAN5"},{I2C_MASTER_CH_7,0x77,1,NONE,"FAN4"},{I2C_MASTER_CH_7,0x77,3,NONE,"FAN2"},{I2C_MASTER_CH_7,0x77,4,NONE,"FAN1"},
+    /* BUS8 POWER MONITOR */
+    {I2C_MASTER_CH_8,0xFF,0,NONE,"UCD90120"},
+    /* BUS9 LM75 */
+    {I2C_MASTER_CH_9,0xFF,0,NONE,"LM75"},
+};
+#else
+/* PREDEFINED I2C SWITCH DEVICE TOPOLOGY */
+static struct i2c_switch fpga_i2c_bus_dev[] = {
+    /* BUS1 SFP Exported as virtual bus */
+    {I2C_MASTER_CH_10,0x72,0,SFP,"SFP1"}, {I2C_MASTER_CH_10,0x72,1,SFP,"SFP2"}, {I2C_MASTER_CH_10,0x72,2,SFP,"SFP3"}, {I2C_MASTER_CH_10,0x72,3,SFP,"SFP4"},
+    {I2C_MASTER_CH_10,0x72,4,SFP,"SFP5"}, {I2C_MASTER_CH_10,0x72,5,SFP,"SFP6"}, {I2C_MASTER_CH_10,0x72,6,SFP,"SFP7"}, {I2C_MASTER_CH_10,0x72,7,SFP,"SFP8"},
+    {I2C_MASTER_CH_10,0x73,0,SFP,"SFP9"}, {I2C_MASTER_CH_10,0x73,1,SFP,"SFP10"},{I2C_MASTER_CH_10,0x73,2,SFP,"SFP11"},{I2C_MASTER_CH_10,0x73,3,SFP,"SFP12"},
+    {I2C_MASTER_CH_10,0x73,4,SFP,"SFP13"},{I2C_MASTER_CH_10,0x73,5,SFP,"SFP14"},{I2C_MASTER_CH_10,0x73,6,SFP,"SFP15"},{I2C_MASTER_CH_10,0x73,7,SFP,"SFP16"},
+    {I2C_MASTER_CH_10,0x74,0,SFP,"SFP17"},{I2C_MASTER_CH_10,0x74,1,SFP,"SFP18"},{I2C_MASTER_CH_10,0x74,2,SFP,"SFP19"},{I2C_MASTER_CH_10,0x74,3,SFP,"SFP20"},
+    {I2C_MASTER_CH_10,0x74,4,SFP,"SFP21"},{I2C_MASTER_CH_10,0x74,5,SFP,"SFP22"},{I2C_MASTER_CH_10,0x74,6,SFP,"SFP23"},{I2C_MASTER_CH_10,0x74,7,SFP,"SFP24"},
+    {I2C_MASTER_CH_10,0x75,0,SFP,"SFP25"},{I2C_MASTER_CH_10,0x75,1,SFP,"SFP26"},{I2C_MASTER_CH_10,0x75,2,SFP,"SFP27"},{I2C_MASTER_CH_10,0x75,3,SFP,"SFP28"},
+    {I2C_MASTER_CH_10,0x75,4,SFP,"SFP29"},{I2C_MASTER_CH_10,0x75,5,SFP,"SFP30"},{I2C_MASTER_CH_10,0x75,6,SFP,"SFP31"},{I2C_MASTER_CH_10,0x75,7,SFP,"SFP32"},
+    {I2C_MASTER_CH_10,0x76,0,SFP,"SFP33"},{I2C_MASTER_CH_10,0x76,1,SFP,"SFP34"},{I2C_MASTER_CH_10,0x76,2,SFP,"SFP35"},{I2C_MASTER_CH_10,0x76,3,SFP,"SFP36"},
+    {I2C_MASTER_CH_10,0x76,4,SFP,"SFP37"},{I2C_MASTER_CH_10,0x76,5,SFP,"SFP38"},{I2C_MASTER_CH_10,0x76,6,SFP,"SFP39"},{I2C_MASTER_CH_10,0x76,7,SFP,"SFP40"},
+    {I2C_MASTER_CH_10,0x77,0,SFP,"SFP41"},{I2C_MASTER_CH_10,0x77,1,SFP,"SFP42"},{I2C_MASTER_CH_10,0x77,2,SFP,"SFP43"},{I2C_MASTER_CH_10,0x77,3,SFP,"SFP44"},
+    {I2C_MASTER_CH_10,0x77,4,SFP,"SFP45"},{I2C_MASTER_CH_10,0x77,5,SFP,"SFP46"},{I2C_MASTER_CH_10,0x77,6,SFP,"SFP47"},{I2C_MASTER_CH_10,0x77,7,SFP,"SFP48"},
+    /* BUS2 QSFP28 Exported as virtual bus */
+    {I2C_MASTER_CH_2,0x74,4,QSFP,"QSFP1"},{I2C_MASTER_CH_2,0x74,5,QSFP,"QSFP2"},{I2C_MASTER_CH_2,0x74,6,QSFP,"QSFP3"},{I2C_MASTER_CH_2,0x74,7,QSFP,"QSFP4"},
+    {I2C_MASTER_CH_2,0x74,0,QSFP,"QSFP5"},{I2C_MASTER_CH_2,0x74,1,QSFP,"QSFP6"},{I2C_MASTER_CH_2,0x74,2,QSFP,"QSFP7"},{I2C_MASTER_CH_2,0x74,3,QSFP,"QSFP8"},
+    /* BUS3 CPLD Access via SYSFS */
+    {I2C_MASTER_CH_3,0xFF,0,NONE,"CPLD"},
+    /* BUS5 POWER CHIP Exported as virtual bus */
+    {I2C_MASTER_CH_5,0xFF,0,NONE,"POWER"},
+    /* BUS4 CPLD_B */
+    {I2C_MASTER_CH_4,0xFF,0,NONE,"CPLD_B"},
+    /* BUS6 PSU */
+    {I2C_MASTER_CH_6,0xFF,0,NONE,"PSU"},
+    /* BUS7 FAN */
+    /* Channel 2 is no hardware connected */
+    {I2C_MASTER_CH_7,0x77,0,NONE,"FAN5"},{I2C_MASTER_CH_7,0x77,1,NONE,"FAN4"},{I2C_MASTER_CH_7,0x77,3,NONE,"FAN2"},{I2C_MASTER_CH_7,0x77,4,NONE,"FAN1"},
+    /* BUS8 UCD90120 */
+    {I2C_MASTER_CH_8,0xFF,0,NONE,"UCD90120"},
+    /* BUS9 TEMP SENSOR LM75 */
+    {I2C_MASTER_CH_9,0xFF,0,NONE,"LM75"}
+};
+#endif
+struct fpga_device{
+    /* data mmio region */
+    void __iomem *data_base_addr;
+    resource_size_t data_mmio_start;
+    resource_size_t data_mmio_len;
+};
+
+static struct fpga_device fpga_dev = {
+    .data_base_addr = NULL,
+    .data_mmio_start = NULL,
+    .data_mmio_len = NULL,
+};
+
+struct seastone2_fpga_data {
+    struct device *sff_devices[SFF_PORT_TOTAL];
+    struct i2c_client *sff_i2c_clients[SFF_PORT_TOTAL];
+    struct i2c_adapter *i2c_adapter[VIRTUAL_I2C_PORT_LENGTH];
+    struct mutex fpga_lock;         // For FPGA internal lock
+    unsigned long fpga_read_addr;
+    uint8_t cpld1_read_addr;
+    uint8_t cpld2_read_addr;
+};
+
+struct sff_device_data {
+    int portid;
+    enum PORT_TYPE port_type;
+};
+
+struct seastone2_fpga_data *fpga_data;
+
+/*
+ * Kernel object for other module drivers.
+ * Other module can use these kobject as a parent.
+ */
+
+static struct kobject *fpga = NULL;
+static struct kobject *cpld1 = NULL;
+static struct kobject *cpld2 = NULL;
+
+/**
+ * Device node in sysfs tree.
+ */
+static struct device *sff_dev = NULL;
+
+/**
+ * [get_fpga_reg_value description]
+ * @param  dev     [description]
+ * @param  devattr [description]
+ * @param  buf     [description]
+ * @return         [description]
+ */
+static ssize_t get_fpga_reg_value(struct device *dev, struct device_attribute *devattr,
+                char *buf)
+{
+    // read data from the address
+    uint32_t data;
+    data = ioread32(fpga_data->fpga_read_addr);
+    return sprintf(buf,"0x%8.8x\n",data);
+}
+/**
+ * [set_fpga_reg_address description]
+ * @param  dev     [description]
+ * @param  devattr [description]
+ * @param  buf     [description]
+ * @param  count   [description]
+ * @return         [description]
+ */
+static ssize_t set_fpga_reg_address(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    uint32_t addr;
+    char *last;
+
+    addr = (uint32_t)strtoul(buf,&last,16);
+    if(addr == 0 && buf == last){
+        return -EINVAL;
+    }
+    fpga_data->fpga_read_addr = fpga_dev.data_base_addr+addr;
+    return count;
+}
+/**
+ * [get_fpga_scratch description]
+ * @param  dev     [description]
+ * @param  devattr [description]
+ * @param  buf     [description]
+ * @return         [description]
+ */
+static ssize_t get_fpga_scratch(struct device *dev, struct device_attribute *devattr,
+                char *buf)
+{
+    return sprintf(buf,"0x%8.8x\n", ioread32(fpga_dev.data_base_addr+FPGA_SCRATCH) & 0xffffffff);
+}
+/**
+ * [set_fpga_scratch description]
+ * @param  dev     [description]
+ * @param  devattr [description]
+ * @param  buf     [description]
+ * @param  count   [description]
+ * @return         [description]
+ */
+static ssize_t set_fpga_scratch(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    uint32_t data;
+    char *last;
+    data = (uint32_t)strtoul(buf,&last,16);
+    if(data == 0 && buf == last){
+        return -EINVAL;
+    }
+    iowrite32(data, fpga_dev.data_base_addr+FPGA_SCRATCH);
+    return count;
+}
+/**
+ * [set_fpga_reg_value description]
+ * @param  dev     [description]
+ * @param  devattr [description]
+ * @param  buf     [description]
+ * @return         [description]
+ */
+static ssize_t set_fpga_reg_value(struct device *dev, struct device_attribute *devattr,
+                const char *buf, size_t count)
+{
+    //register is 4 bytes
+    uint32_t addr;
+    uint32_t value;
+    uint32_t mode = 8;
+    char *tok;
+    char clone[count];
+    char *pclone = clone;
+    char *last;
+
+    strcpy(clone, buf);
+
+    mutex_lock(&fpga_data->fpga_lock);
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        mutex_unlock(&fpga_data->fpga_lock);
+        return -EINVAL;
+    }
+    addr = (uint32_t)strtoul(tok,&last,16);
+    if(addr == 0 && tok == last){
+        mutex_unlock(&fpga_data->fpga_lock);
+        return -EINVAL;
+    }
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        mutex_unlock(&fpga_data->fpga_lock);
+        return -EINVAL;
+    }
+    value = (uint32_t)strtoul(tok,&last,16);
+    if(value == 0 && tok == last){
+        mutex_unlock(&fpga_data->fpga_lock);
+        return -EINVAL;
+    }
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        mode = 32;
+    }else{
+        mode = (uint32_t)strtoul(tok,&last,10);
+        if(mode == 0 && tok == last){
+            mutex_unlock(&fpga_data->fpga_lock);
+            return -EINVAL;
+        }
+    }
+    if(mode == 32){
+        iowrite32(value, fpga_dev.data_base_addr+addr);
+    }else if(mode == 8){
+        iowrite8(value, fpga_dev.data_base_addr+addr);
+    }else{
+        mutex_unlock(&fpga_data->fpga_lock);
+        return -EINVAL;
+    }
+    mutex_unlock(&fpga_data->fpga_lock);
+    return count;
+}
+
+/**
+ * Read all FPGA XCVR register in binary mode.
+ * @param  filp  [description]
+ * @param  kobj  [description]
+ * @param  attr  [description]
+ * @param  buf   [description]
+ * @param  off   [description]
+ * @param  count [description]
+ * @return       [description]
+ */
+static ssize_t dump_read(struct file *filp, struct kobject *kobj,
+                struct bin_attribute *attr, char *buf,
+                loff_t off, size_t count)
+{
+    unsigned long i=0;
+    ssize_t status;
+    u8 read_reg;
+
+    if( off + count > PORT_XCVR_REGISTER_SIZE ){
+        return -EINVAL;
+    }
+    mutex_lock(&fpga_data->fpga_lock);
+    while(i < count){
+        read_reg = ioread8(fpga_dev.data_base_addr + SFF_PORT_CTRL_BASE + off + i);
+        buf[i++] = read_reg;
+    }
+    status = count;
+    mutex_unlock(&fpga_data->fpga_lock);
+    return status;
+}
+
+/**
+ * Show FPGA port XCVR ready status
+ * @param  dev  [description]
+ * @param  attr [description]
+ * @param  buf  [description]
+ * @return      [description]
+ */
+static ssize_t ready_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int REGISTER = FPGA_PORT_XCVR_READY;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> 0) & 1U);
+}
+
+/* FPGA attributes */
+static DEVICE_ATTR( getreg, 0600, get_fpga_reg_value, set_fpga_reg_address);
+static DEVICE_ATTR( scratch, 0600, get_fpga_scratch, set_fpga_scratch);
+static DEVICE_ATTR( setreg, 0200, NULL , set_fpga_reg_value);
+static DEVICE_ATTR_RO(ready);
+static BIN_ATTR_RO( dump, PORT_XCVR_REGISTER_SIZE);
+
+static struct bin_attribute *fpga_bin_attrs[] = {
+        &bin_attr_dump,
+        NULL,
+};
+
+static struct attribute *fpga_attrs[] = {
+        &dev_attr_getreg.attr,
+        &dev_attr_scratch.attr,
+        &dev_attr_setreg.attr,
+        &dev_attr_ready.attr,
+        NULL,
+};
+
+static struct attribute_group fpga_attr_grp = {
+        .attrs = fpga_attrs,
+        .bin_attrs = fpga_bin_attrs,
+};
+
+/* SW CPLDs attributes */
+static ssize_t cpld1_dump_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // CPLD register is one byte
+    uint8_t data;
+    fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,I2C_SMBUS_READ,fpga_data->cpld1_read_addr,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&data);
+    return sprintf(buf,"0x%2.2x\n",data);
+}
+static ssize_t cpld1_dump_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    uint8_t addr;
+    char *last;
+    addr = (uint8_t)strtoul(buf,&last,16);
+    if(addr == 0 && buf == last){
+        return -EINVAL;
+    }
+    fpga_data->cpld1_read_addr = addr;
+    return size;
+}
+struct device_attribute dev_attr_cpld1_dump = __ATTR(dump,0600,cpld1_dump_show,cpld1_dump_store);
+
+static ssize_t cpld1_scratch_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // CPLD register is one byte
+    __u8 data;
+    int err;
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,I2C_SMBUS_READ,0x01,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&data);
+    if(err < 0)
+        return err;
+    return sprintf(buf, "0x%2.2x\n",data);
+}
+static ssize_t cpld1_scratch_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    // CPLD register is one byte
+    __u8 data;
+    char *last;
+    int err;
+    data = (uint8_t)strtoul(buf,&last,16);
+    if(data == 0 && buf == last){
+        return -EINVAL;
+    }
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,I2C_SMBUS_WRITE,0x01,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&data);
+    if(err < 0)
+        return err;
+    return size;
+}
+struct device_attribute dev_attr_cpld1_scratch = __ATTR(scratch,0600,cpld1_scratch_show,cpld1_scratch_store);
+
+static ssize_t cpld1_setreg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+
+    uint8_t addr,value;
+    char *tok;
+    char clone[size];
+    char *pclone = clone;
+    int err;
+    char *last;
+
+    strcpy(clone, buf);
+
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        return sprintf(buf,"ERROR line %d",__LINE__);
+    }
+    addr = (uint8_t)strtoul(tok,&last,16);
+    if(addr == 0 && tok == last){
+        return -EINVAL;
+    }
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        return sprintf(buf,"ERROR line %d",__LINE__);
+    }
+    value = (uint8_t)strtoul(tok,&last,16);
+    if(value == 0 && tok == last){
+        return -EINVAL;
+    }
+
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,I2C_SMBUS_WRITE,addr,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&value);
+    if(err < 0)
+        return sprintf(buf,"ERROR line %d",__LINE__);
+
+    return size;
+}
+struct device_attribute dev_attr_cpld1_setreg = __ATTR(setreg,0200,NULL,cpld1_setreg_store);
+
+static struct attribute *cpld1_attrs[] = {
+        &dev_attr_cpld1_dump.attr,
+        &dev_attr_cpld1_scratch.attr,
+        &dev_attr_cpld1_setreg.attr,
+        NULL,
+};
+
+static struct attribute_group cpld1_attr_grp = {
+        .attrs = cpld1_attrs,
+};
+
+static ssize_t cpld2_dump_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // CPLD register is one byte
+    uint8_t data;
+    fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,I2C_SMBUS_READ,fpga_data->cpld2_read_addr,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&data);
+    return sprintf(buf,"0x%2.2x\n",data);
+}
+static ssize_t cpld2_dump_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    // CPLD register is one byte
+    uint32_t addr;
+    char *last;
+    addr = (uint8_t)strtoul(buf,&last,16);
+    if(addr == 0 && buf == last){
+        return -EINVAL;
+    }
+    fpga_data->cpld2_read_addr = addr;
+    return size;
+}
+struct device_attribute dev_attr_cpld2_dump = __ATTR(dump,0600,cpld2_dump_show,cpld2_dump_store);
+
+static ssize_t cpld2_scratch_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // CPLD register is one byte
+    __u8 data;
+    int err;
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,I2C_SMBUS_READ,0x01,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&data);
+    if(err < 0)
+        return err;
+    return sprintf(buf, "0x%2.2x\n",data);
+}
+static ssize_t cpld2_scratch_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    // CPLD register is one byte
+    __u8 data;
+    char *last;
+    int err;
+
+    data = (uint8_t)strtoul(buf,&last,16);
+    if(data == 0 && buf == last){
+        return -EINVAL;
+    }
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,I2C_SMBUS_WRITE,0x01,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&data);
+    if(err < 0)
+        return err;
+    return size;
+}
+struct device_attribute dev_attr_cpld2_scratch = __ATTR(scratch,0600,cpld2_scratch_show,cpld2_scratch_store);
+
+static ssize_t cpld2_setreg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    uint8_t addr,value;
+    char *tok;
+    char clone[size];
+    char *pclone = clone;
+    int err;
+    char *last;
+
+    strcpy(clone, buf);
+
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        return -EINVAL;
+    }
+    addr = (uint8_t)strtoul(tok,&last,16);
+    if(addr == 0 && tok == last){
+        return -EINVAL;
+    }
+    tok = strsep((char**)&pclone, " ");
+    if(tok == NULL){
+        return -EINVAL;
+    }
+    value = (uint8_t)strtoul(tok,&last,16);
+    if(value == 0 && tok == last){
+        return -EINVAL;
+    }
+
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,I2C_SMBUS_WRITE,addr,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&value);
+    if(err < 0)
+        return err;
+
+    return size;
+}
+struct device_attribute dev_attr_cpld2_setreg = __ATTR(setreg,0200,NULL,cpld2_setreg_store);
+
+static struct attribute *cpld2_attrs[] = {
+        &dev_attr_cpld2_dump.attr,
+        &dev_attr_cpld2_scratch.attr,
+        &dev_attr_cpld2_setreg.attr,
+        NULL,
+};
+
+static struct attribute_group cpld2_attr_grp = {
+        .attrs = cpld2_attrs,
+};
+
+/* QSFP/SFP+ attributes */
+static ssize_t qsfp_modirq_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_STATUS_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> STAT_IRQ) & 1U);
+}
+DEVICE_ATTR_RO(qsfp_modirq);
+
+static ssize_t qsfp_modprs_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_STATUS_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> STAT_PRESENT) & 1U);
+}
+DEVICE_ATTR_RO(qsfp_modprs);
+
+static ssize_t sfp_txfault_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_STATUS_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> STAT_TXFAULT) & 1U);
+}
+DEVICE_ATTR_RO(sfp_txfault);
+
+static ssize_t sfp_rxlos_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_STATUS_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> STAT_RXLOS) & 1U);
+}
+DEVICE_ATTR_RO(sfp_rxlos);
+
+static ssize_t sfp_modabs_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_STATUS_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> STAT_MODABS) & 1U);
+}
+DEVICE_ATTR_RO(sfp_modabs);
+
+static ssize_t qsfp_lpmode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_CTRL_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> CTRL_LPMOD) & 1U);
+}
+static ssize_t qsfp_lpmode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    ssize_t status;
+    long value;
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_CTRL_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    status = kstrtol(buf, 0, &value);
+    if (status == 0) {
+        // check if value is 0 clear
+        data = ioread32(fpga_dev.data_base_addr+REGISTER);
+        if(!value)
+            data = data & ~( (u32)0x1 << CTRL_LPMOD);
+        else
+            data = data | ((u32)0x1 << CTRL_LPMOD);
+        iowrite32(data,fpga_dev.data_base_addr+REGISTER);
+        status = size;
+    }
+    mutex_unlock(&fpga_data->fpga_lock);
+    return status;
+}
+DEVICE_ATTR_RW(qsfp_lpmode);
+
+static ssize_t qsfp_reset_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_CTRL_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> CTRL_RST) & 1U);
+}
+
+static ssize_t qsfp_reset_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    ssize_t status;
+    long value;
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_CTRL_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    status = kstrtol(buf, 0, &value);
+    if (status == 0) {
+        // check if value is 0 clear
+        data = ioread32(fpga_dev.data_base_addr+REGISTER);
+        if(!value)
+            data = data & ~( (u32)0x1 << CTRL_RST);
+        else
+            data = data | ((u32)0x1 << CTRL_RST);
+        iowrite32(data,fpga_dev.data_base_addr+REGISTER);
+        status = size;
+    }
+    mutex_unlock(&fpga_data->fpga_lock);
+    return status;
+}
+DEVICE_ATTR_RW(qsfp_reset);
+
+static ssize_t sfp_txdisable_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_CTRL_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    data = ioread32(fpga_dev.data_base_addr+REGISTER);
+    mutex_unlock(&fpga_data->fpga_lock);
+    return sprintf(buf, "%d\n", (data >> CTRL_TXDIS) & 1U);
+}
+static ssize_t sfp_txdisable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    ssize_t status;
+    long value;
+    u32 data;
+    struct sff_device_data *dev_data = dev_get_drvdata(dev);
+    unsigned int portid = dev_data->portid;
+    unsigned int REGISTER = SFF_PORT_CTRL_BASE + (portid-1)*0x10;
+
+    mutex_lock(&fpga_data->fpga_lock);
+    status = kstrtol(buf, 0, &value);
+    if (status == 0) {
+        // check if value is 0 clear
+        data = ioread32(fpga_dev.data_base_addr+REGISTER);
+        if(!value)
+            data = data & ~( (u32)0x1 << CTRL_TXDIS);
+        else
+            data = data | ((u32)0x1 << CTRL_TXDIS);
+        iowrite32(data,fpga_dev.data_base_addr+REGISTER);
+        status = size;
+    }
+    mutex_unlock(&fpga_data->fpga_lock);
+    return status;
+}
+DEVICE_ATTR_RW(sfp_txdisable);
+
+static struct attribute *sff_attrs[] = {
+    &dev_attr_qsfp_modirq.attr,
+    &dev_attr_qsfp_modprs.attr,
+    &dev_attr_qsfp_lpmode.attr,
+    &dev_attr_qsfp_reset.attr,
+    &dev_attr_sfp_txfault.attr,
+    &dev_attr_sfp_rxlos.attr,
+    &dev_attr_sfp_modabs.attr,
+    &dev_attr_sfp_txdisable.attr,
+    NULL,
+};
+
+static struct attribute_group sff_attr_grp = {
+        .attrs = sff_attrs,
+};
+
+static const struct attribute_group *sff_attr_grps[] = {
+    &sff_attr_grp,
+    NULL
+};
+
+
+static ssize_t port_led_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // value can be "nomal", "test"
+    __u8 led_mode_1,led_mode_2;
+    int err;
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,I2C_SMBUS_READ,0x09,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_mode_1);
+    if(err < 0)
+        return err;
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,I2C_SMBUS_READ,0x09,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_mode_2);
+    if(err < 0)
+        return err;
+    return sprintf(buf, "%s %s\n",
+            led_mode_1 ? "test" : "normal",
+            led_mode_2 ? "test" : "normal");
+}
+static ssize_t port_led_mode_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    int status;
+    __u8 led_mode_1;
+    if(sysfs_streq(buf, "test")){
+        led_mode_1 = 0x01;
+    }else if(sysfs_streq(buf, "normal")){
+        led_mode_1 = 0x00;
+    }else{
+        return -EINVAL;
+    }
+    status = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,
+        I2C_SMBUS_WRITE,0x09,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_mode_1);
+    status = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,
+        I2C_SMBUS_WRITE,0x09,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_mode_1);
+    return size;
+}
+DEVICE_ATTR_RW(port_led_mode);
+
+// Only work when port_led_mode set to 1
+static ssize_t port_led_color_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    // value can be "off", "green", "amber", "both"
+    __u8 led_color1,led_color2;
+    int err;
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,I2C_SMBUS_READ,0x09,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_color1);
+    if(err < 0)
+        return err;
+    err = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,I2C_SMBUS_READ,0x09,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_color2);
+    if(err < 0)
+        return err;
+    return sprintf(buf, "%s %s\n",
+            led_color1 == 0x03 ? "off" : led_color1 == 0x02 ? "green" : led_color1 ==0x01 ? "amber": "both",
+            led_color2 == 0x03 ? "off" : led_color2 == 0x02 ? "green" : led_color2 ==0x01 ? "amber": "both");
+}
+
+static ssize_t port_led_color_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+    int status;
+    __u8 led_color;
+    if(sysfs_streq(buf, "off")){
+        led_color = 0x03;
+    }else if(sysfs_streq(buf, "green")){
+        led_color = 0x02;
+    }else if(sysfs_streq(buf, "amber")){
+        led_color = 0x01;
+    }else if(sysfs_streq(buf, "both")){
+        led_color = 0x00;
+    }else{
+        status = -EINVAL;
+        return status;
+    }
+    status = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,
+        I2C_SMBUS_WRITE,0x0A,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_color);
+    status = fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,
+        I2C_SMBUS_WRITE,0x0A,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&led_color);
+    return size;
+}
+DEVICE_ATTR_RW(port_led_color);
+
+static struct attribute *sff_led_test[] = {
+    &dev_attr_port_led_mode.attr,
+    &dev_attr_port_led_color.attr,
+    NULL,
+};
+
+static struct attribute_group sff_led_test_grp = {
+        .attrs = sff_led_test,
+};
+
+static struct device * seastone2_sff_init(int portid){
+    struct sff_device_data *new_data;
+    struct device *new_device;
+
+    new_data = kzalloc(sizeof(*new_data), GFP_KERNEL);
+    if (!new_data) {
+        printk(KERN_ALERT "Cannot alloc sff device data @port%d", portid);
+        return NULL;
+    }
+    /* The QSFP port ID start from 1 */
+    new_data->portid = portid+1;
+    new_data->port_type = fpga_i2c_bus_dev[portid].port_type;
+    new_device = device_create_with_groups(fpgafwclass, sff_dev, MKDEV(0,0), new_data, sff_attr_grps, "%s",fpga_i2c_bus_dev[portid].calling_name);
+    if (IS_ERR(new_device)) {
+        printk(KERN_ALERT "Cannot create sff device @port%d", portid);
+        kfree(new_data);
+        return NULL;
+    }
+    return new_device;
+}
+
+static int i2c_wait_ack(struct i2c_adapter *a,unsigned long timeout,int writing){
+    int error = 0;
+    int Status;
+
+    struct i2c_dev_data *new_data = i2c_get_adapdata(a);
+    void __iomem *pci_bar = fpga_dev.data_base_addr;
+
+    unsigned int REG_FDR0;
+    unsigned int REG_CR0;
+    unsigned int REG_SR0;
+    unsigned int REG_DR0;
+    unsigned int REG_ID0;
+
+    unsigned int master_bus = new_data->pca9548.master_bus;
+
+    if(master_bus < I2C_MASTER_CH_1 || master_bus > I2C_MASTER_CH_TOTAL){
+        error = -ENXIO;
+        return error;
+    }
+
+    REG_FDR0  = I2C_MASTER_FREQ_1    + (master_bus-1)*0x0100;
+    REG_CR0   = I2C_MASTER_CTRL_1    + (master_bus-1)*0x0100;
+    REG_SR0   = I2C_MASTER_STATUS_1  + (master_bus-1)*0x0100;
+    REG_DR0   = I2C_MASTER_DATA_1    + (master_bus-1)*0x0100;
+    REG_ID0   = I2C_MASTER_PORT_ID_1 + (master_bus-1)*0x0100;
+
+    check(pci_bar+REG_SR0);
+    check(pci_bar+REG_CR0);
+
+    timeout = jiffies + msecs_to_jiffies(timeout);
+    while(1){
+        Status = ioread8(pci_bar+REG_SR0);
+        if(jiffies > timeout){
+            info("Status %2.2X",Status);
+            info("Error Timeout");
+            error = -ETIMEDOUT;
+            break;
+        }
+
+
+        if(Status & (1 << I2C_SR_BIT_MIF)){
+            break;
+        }
+
+        if(writing == 0 && (Status & (1<<I2C_SR_BIT_MCF))){
+            break;
+        }
+    }
+    Status = ioread8(pci_bar+REG_SR0);
+    iowrite8(0, pci_bar+REG_SR0);
+
+    if(error<0){
+        info("Status %2.2X",Status);
+        return error;
+    }
+
+    if(!(Status & (1 << I2C_SR_BIT_MCF))){
+        info("Error Unfinish");
+        return -EIO;
+    }
+
+    if(Status & (1 <<I2C_SR_BIT_MAL)){
+        info("Error MAL");
+        return -EAGAIN;
+    }
+
+    if(Status & (1 << I2C_SR_BIT_RXAK)){
+        info( "SL No Acknowlege");
+        if(writing){
+            info("Error No Acknowlege");
+            iowrite8(1<<I2C_CR_BIT_MEN,pci_bar+REG_CR0);
+            return -ENXIO;
+        }
+    }else{
+        info( "SL Acknowlege");
+    }
+
+    return 0;
+}
+
+static int smbus_access(struct i2c_adapter *adapter, u16 addr,
+              unsigned short flags, char rw, u8 cmd,
+              int size, union i2c_smbus_data *data)
+{
+        int error = 0;
+        struct i2c_dev_data *dev_data;
+        /* Write the command register */
+        dev_data = i2c_get_adapdata(adapter);
+
+        unsigned int  portid = dev_data->portid;
+        void __iomem *pci_bar = fpga_dev.data_base_addr;
+
+#ifdef DEBUG_KERN
+        printk(KERN_INFO "portid %2d|@ 0x%2.2X|f 0x%4.4X|(%d)%-5s| (%d)%-15s|CMD %2.2X "
+            ,portid,addr,flags,rw,rw == 1 ? "READ ":"WRITE"
+            ,size,                  size == 0 ? "QUICK" :
+                                    size == 1 ? "BYTE" :
+                                    size == 2 ? "BYTE_DATA" :
+                                    size == 3 ? "WORD_DATA" :
+                                    size == 4 ? "PROC_CALL" :
+                                    size == 5 ? "BLOCK_DATA" :
+                                    size == 8 ? "I2C_BLOCK_DATA" :  "ERROR"
+            ,cmd);
+#endif
+        /* Map the size to what the chip understands */
+        switch (size) {
+            case I2C_SMBUS_QUICK:
+            case I2C_SMBUS_BYTE:
+            case I2C_SMBUS_BYTE_DATA:
+            case I2C_SMBUS_WORD_DATA:
+            case I2C_SMBUS_BLOCK_DATA:
+            case I2C_SMBUS_I2C_BLOCK_DATA:
+                break;
+            default:
+                printk(KERN_INFO "Unsupported transaction %d\n", size);
+                error = -EOPNOTSUPP;
+                goto Done;
+        }
+
+        unsigned int REG_FDR0;
+        unsigned int REG_CR0;
+        unsigned int REG_SR0;
+        unsigned int REG_DR0;
+        unsigned int REG_ID0;
+
+        unsigned int master_bus = dev_data->pca9548.master_bus;
+
+        if(master_bus < I2C_MASTER_CH_1 || master_bus > I2C_MASTER_CH_TOTAL){
+            error = -ENXIO;
+            goto Done;
+        }
+
+        REG_FDR0  = I2C_MASTER_FREQ_1    + (master_bus-1)*0x0100;
+        REG_CR0   = I2C_MASTER_CTRL_1    + (master_bus-1)*0x0100;
+        REG_SR0   = I2C_MASTER_STATUS_1  + (master_bus-1)*0x0100;
+        REG_DR0   = I2C_MASTER_DATA_1    + (master_bus-1)*0x0100;
+        REG_ID0   = I2C_MASTER_PORT_ID_1 + (master_bus-1)*0x0100;
+
+        iowrite8(portid,pci_bar+REG_ID0);
+
+        int cnt=0;
+
+        ////[S][ADDR/R]
+        // Clear status register
+        iowrite8(0,pci_bar+REG_SR0);
+        iowrite8(1 << I2C_CR_BIT_MIEN | 1 << I2C_CR_BIT_MTX | 1 << I2C_CR_BIT_MSTA ,pci_bar+REG_CR0);
+        SET_REG_BIT_H(pci_bar+REG_CR0,I2C_CR_BIT_MEN);
+
+        if(rw == I2C_SMBUS_READ &&
+                (size == I2C_SMBUS_QUICK || size == I2C_SMBUS_BYTE)){
+            // sent device address with Read mode
+            iowrite8(addr << 1 | 0x01,pci_bar+REG_DR0);
+        }else{
+            // sent device address with Write mode
+           iowrite8(addr << 1 | 0x00,pci_bar+REG_DR0);
+        }
+
+
+
+        info( "MS Start");
+
+        //// Wait {A}
+        error = i2c_wait_ack(adapter,12,1);
+        if(error<0){
+            info( "get error %d",error);
+            goto Done;
+        }
+
+        //// [CMD]{A}
+        if(size == I2C_SMBUS_BYTE_DATA ||
+            size == I2C_SMBUS_WORD_DATA ||
+            size == I2C_SMBUS_BLOCK_DATA ||
+            size == I2C_SMBUS_I2C_BLOCK_DATA ||
+            (size == I2C_SMBUS_BYTE && rw == I2C_SMBUS_WRITE)){
+
+            // sent command code to data register
+            iowrite8(cmd,pci_bar+REG_DR0);
+            info( "MS Send CMD 0x%2.2X",cmd);
+
+            // Wait {A}
+            error = i2c_wait_ack(adapter,12,1);
+            if(error<0){
+                info( "get error %d",error);
+                goto Done;
+            }
+        }
+
+        switch(size){
+            case I2C_SMBUS_BYTE_DATA:
+                    cnt = 1;  break;
+            case I2C_SMBUS_WORD_DATA:
+                    cnt = 2;  break;
+            case I2C_SMBUS_BLOCK_DATA:
+            case I2C_SMBUS_I2C_BLOCK_DATA:
+            /* In block data modes keep number of byte in block[0] */
+                    cnt = data->block[0];
+                              break;
+            default:
+                    cnt = 0;  break;
+        }
+
+        // [CNT]  used only block data write
+        if(size == I2C_SMBUS_BLOCK_DATA && rw == I2C_SMBUS_WRITE){
+
+            iowrite8(cnt,pci_bar+REG_DR0);
+            info( "MS Send CNT 0x%2.2X",cnt);
+
+            // Wait {A}
+            error = i2c_wait_ack(adapter,12,1);
+            if(error<0){
+                info( "get error %d",error);
+                goto Done;
+            }
+        }
+
+        // [DATA]{A}
+        if( rw == I2C_SMBUS_WRITE && (
+                    size == I2C_SMBUS_BYTE ||
+                    size == I2C_SMBUS_BYTE_DATA ||
+                    size == I2C_SMBUS_WORD_DATA ||
+                    size == I2C_SMBUS_BLOCK_DATA ||
+                    size == I2C_SMBUS_I2C_BLOCK_DATA
+            )){
+            int bid=0;
+            info( "MS prepare to sent [%d bytes]",cnt);
+            if(size == I2C_SMBUS_BLOCK_DATA || size == I2C_SMBUS_I2C_BLOCK_DATA){
+                bid=1;      // block[0] is cnt;
+                cnt+=1;     // offset from block[0]
+            }
+            for(;bid<cnt;bid++){
+
+                iowrite8(data->block[bid],pci_bar+REG_DR0);
+                info( "   Data > %2.2X",data->block[bid]);
+                // Wait {A}
+                error = i2c_wait_ack(adapter,12,1);
+                if(error<0){
+                    goto Done;
+                }
+            }
+
+        }
+
+        // REPEATE START
+        if( rw == I2C_SMBUS_READ && (
+                size == I2C_SMBUS_BYTE_DATA ||
+                size == I2C_SMBUS_WORD_DATA ||
+                size == I2C_SMBUS_BLOCK_DATA ||
+                size == I2C_SMBUS_I2C_BLOCK_DATA
+            )){
+            info( "MS Repeated Start");
+
+            SET_REG_BIT_L(pci_bar+REG_CR0,I2C_CR_BIT_MEN);
+            iowrite8(1 << I2C_CR_BIT_MIEN |
+                1 << I2C_CR_BIT_MTX |
+                1 << I2C_CR_BIT_MSTA |
+                1 << I2C_CR_BIT_RSTA ,pci_bar+REG_CR0);
+            SET_REG_BIT_H(pci_bar+REG_CR0,I2C_CR_BIT_MEN);
+
+            // sent Address with Read mode
+            iowrite8( addr<<1 | 0x1 ,pci_bar+REG_DR0);
+
+            // Wait {A}
+            error = i2c_wait_ack(adapter,12,1);
+            if(error<0){
+                goto Done;
+            }
+
+        }
+
+        if( rw == I2C_SMBUS_READ && (
+                size == I2C_SMBUS_BYTE ||
+                size == I2C_SMBUS_BYTE_DATA ||
+                size == I2C_SMBUS_WORD_DATA ||
+                size == I2C_SMBUS_BLOCK_DATA ||
+                size == I2C_SMBUS_I2C_BLOCK_DATA
+            )){
+
+            switch(size){
+                case I2C_SMBUS_BYTE:
+                case I2C_SMBUS_BYTE_DATA:
+                        cnt = 1;  break;
+                case I2C_SMBUS_WORD_DATA:
+                        cnt = 2;  break;
+                case I2C_SMBUS_BLOCK_DATA:
+                    // will be changed after recived first data
+                        cnt = 3;  break;
+                case I2C_SMBUS_I2C_BLOCK_DATA:
+                        cnt = data->block[0];  break;
+                default:
+                        cnt = 0;  break;
+            }
+
+            int bid = 0;
+            info( "MS Receive");
+
+            //set to Receive mode
+            iowrite8(1 << I2C_CR_BIT_MEN |
+                1 << I2C_CR_BIT_MIEN |
+                1 << I2C_CR_BIT_MSTA , pci_bar+REG_CR0);
+
+            for(bid=-1;bid<cnt;bid++){
+
+                // Wait for byte transfer
+                error = i2c_wait_ack(adapter,12,0);
+                if(error<0){
+                    goto Done;
+                }
+
+                if(bid == cnt-2){
+                    info( "SET NAK");
+                    SET_REG_BIT_H(pci_bar+REG_CR0,I2C_CR_BIT_TXAK);
+                }
+
+                if(bid<0){
+                    ioread8(pci_bar+REG_DR0);
+                    info( "READ Dummy Byte" );
+                }else{
+
+                    if(bid==cnt-1){
+                        info ( "SET STOP in read loop");
+                        SET_REG_BIT_L(pci_bar+REG_CR0,I2C_CR_BIT_MSTA);
+                    }
+                    if(size == I2C_SMBUS_I2C_BLOCK_DATA){
+                        // block[0] is read length
+                        data->block[bid+1] = ioread8(pci_bar+REG_DR0);
+                    }else {
+                        data->block[bid] = ioread8(pci_bar+REG_DR0);
+                    }
+                    info( "DATA IN [%d] %2.2X",bid,data->block[bid]);
+
+                    if(size == I2C_SMBUS_BLOCK_DATA && bid == 0){
+                        cnt = data->block[0] + 1;
+                    }
+                }
+            }
+        }
+
+Stop:
+        // [P]
+        SET_REG_BIT_L(pci_bar+REG_CR0,I2C_CR_BIT_MSTA);
+        info( "MS STOP");
+
+Done:
+        iowrite8(1<<I2C_CR_BIT_MEN,pci_bar+REG_CR0);
+        check(pci_bar+REG_CR0);
+        check(pci_bar+REG_SR0);
+#ifdef DEBUG_KERN
+        printk(KERN_INFO "END --- Error code  %d",error);
+#endif
+        return error;
+}
+
+/**
+ * Wrapper of smbus_access access with PCA9548 I2C switch management.
+ * This function set PCA9548 switches to the proper slave channel.
+ * Only one channel among switches chip is selected during communication time.
+ *
+ * Note: If the bus does not have any PCA9548 on it, the switch_addr must be
+ * set to 0xFF, it will use normal smbus_access function.
+ */
+static int fpga_i2c_access(struct i2c_adapter *adapter, u16 addr,
+              unsigned short flags, char rw, u8 cmd,
+              int size, union i2c_smbus_data *data)
+{
+    int error = 0;
+    struct i2c_dev_data *dev_data;
+    dev_data = i2c_get_adapdata(adapter);
+    unsigned char master_bus = dev_data->pca9548.master_bus;
+    unsigned char switch_addr = dev_data->pca9548.switch_addr;
+    unsigned char channel = dev_data->pca9548.channel;
+
+    // Acquire the master resource.
+    mutex_lock(&fpga_i2c_master_locks[master_bus-1]);
+    uint16_t prev_port = fpga_i2c_lasted_access_port[master_bus-1];
+
+    if(switch_addr != 0xFF){
+        // Check lasted access switch address on a master
+        if((unsigned char)(prev_port >> 8) == switch_addr){
+            // check if channel is the same
+            if((unsigned char)(prev_port & 0x00FF) != channel){
+                // set new PCA9548 at switch_addr to current
+                error= smbus_access(adapter,switch_addr,flags,I2C_SMBUS_WRITE,1 << channel,I2C_SMBUS_BYTE,NULL);
+                // update lasted port
+                fpga_i2c_lasted_access_port[master_bus-1] = switch_addr << 8 | channel;
+            }
+        }else{
+            // reset prev_port PCA9548 chip
+            error= smbus_access(adapter,(u16)(prev_port >> 8),flags,I2C_SMBUS_WRITE,0x00,I2C_SMBUS_BYTE,NULL);
+            // set PCA9548 to current channel
+            error= smbus_access(adapter,switch_addr,flags,I2C_SMBUS_WRITE,1 << channel,I2C_SMBUS_BYTE,NULL);
+            // update lasted port
+            fpga_i2c_lasted_access_port[master_bus-1] = switch_addr << 8 | channel;
+        }
+    }
+
+    // Do SMBus communication
+    error = smbus_access(adapter,addr,flags,rw,cmd,size,data);
+    // reset the channel
+    mutex_unlock(&fpga_i2c_master_locks[master_bus-1]);
+    return error;
+}
+
+
+
+/**
+ * A callback function show available smbus functions.
+ */
+static u32 fpga_i2c_func(struct i2c_adapter *a)
+{
+    return I2C_FUNC_SMBUS_QUICK  |
+        I2C_FUNC_SMBUS_BYTE      |
+        I2C_FUNC_SMBUS_BYTE_DATA |
+        I2C_FUNC_SMBUS_WORD_DATA |
+        I2C_FUNC_SMBUS_BLOCK_DATA|
+        I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm seastone2_i2c_algorithm = {
+    .smbus_xfer = fpga_i2c_access,
+    .functionality  = fpga_i2c_func,
+};
+
+/**
+ * Create virtual I2C bus adapter for switch devices
+ * @param  pdev             platform device pointer
+ * @param  portid           virtual i2c port id for switch device mapping
+ * @param  bus_number_offset bus offset for virtual i2c adapter in system
+ * @return                  i2c adapter.
+ *
+ * When bus_number_offset is -1, created adapter with dynamic bus number.
+ * Otherwise create adapter at i2c bus = bus_number_offset + portid.
+ */
+static struct i2c_adapter * seastone2_i2c_init(struct platform_device *pdev, int portid, int bus_number_offset)
+{
+    int error;
+
+    struct i2c_adapter *new_adapter;
+    struct i2c_dev_data *new_data;
+
+    new_adapter = kzalloc(sizeof(*new_adapter), GFP_KERNEL);
+    if (!new_adapter){
+        printk(KERN_ALERT "Cannot alloc i2c adapter for %s", fpga_i2c_bus_dev[portid].calling_name);
+        return NULL;
+    }
+
+    new_adapter->owner = THIS_MODULE;
+    new_adapter->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+    new_adapter->algo  = &seastone2_i2c_algorithm;
+    /* If the bus offset is -1, use dynamic bus number */
+    if (bus_number_offset == -1){
+        new_adapter->nr = -1;
+    }else{
+        new_adapter->nr = bus_number_offset + portid;
+    }
+
+    new_data = kzalloc(sizeof(*new_data), GFP_KERNEL);
+    if (!new_data){
+        printk(KERN_ALERT "Cannot alloc i2c data for %s", fpga_i2c_bus_dev[portid].calling_name);
+        kzfree(new_adapter);
+        return NULL;
+    }
+
+    new_data->portid = portid;
+    new_data->pca9548.master_bus = fpga_i2c_bus_dev[portid].master_bus;
+    new_data->pca9548.switch_addr = fpga_i2c_bus_dev[portid].switch_addr;
+    new_data->pca9548.channel = fpga_i2c_bus_dev[portid].channel;
+    strcpy(new_data->pca9548.calling_name,fpga_i2c_bus_dev[portid].calling_name);
+
+    snprintf(new_adapter->name, sizeof(new_adapter->name),
+        "SMBus I2C Adapter PortID: %s", new_data->pca9548.calling_name);
+
+    void __iomem *i2c_freq_base_reg = fpga_dev.data_base_addr+I2C_MASTER_FREQ_1;
+    iowrite8(0x07,i2c_freq_base_reg+(new_data->pca9548.master_bus-1)*0x100); // 0x07 400kHz
+    i2c_set_adapdata(new_adapter,new_data);
+    error = i2c_add_numbered_adapter(new_adapter);
+    if(error < 0){
+        printk(KERN_ALERT "Cannot add i2c adapter %s", new_data->pca9548.calling_name);
+        kzfree(new_adapter);
+        kzfree(new_data);
+        return NULL;
+    }
+
+    return new_adapter;
+};
+
+// I/O resource need.
+static struct resource seastone2_resources[] = {
+    {
+        .start  = 0x10000000,
+        .end    = 0x10001000,
+        .flags  = IORESOURCE_MEM,
+    },
+};
+
+static void seastone2_dev_release( struct device * dev)
+{
+    return;
+}
+
+static struct platform_device seastone2_dev = {
+    .name           = DRIVER_NAME,
+    .id             = -1,
+    .num_resources  = ARRAY_SIZE(seastone2_resources),
+    .resource       = seastone2_resources,
+    .dev = {
+                    .release = seastone2_dev_release,
+    }
+};
+
+/**
+ * Board info for QSFP/SFP+ eeprom.
+ * Note: Using sff8436 as I2C eeprom driver.
+ */
+static struct i2c_board_info sff8436_eeprom_info[] = {
+    { I2C_BOARD_INFO("optoe1", 0x50) },
+    { I2C_BOARD_INFO("optoe2", 0x50) },
+};
+
+static int seastone2_drv_probe(struct platform_device *pdev)
+{
+    struct resource *res;
+    int ret = 0;
+    int portid_count;
+    uint8_t cpld1_version, cpld2_version;
+    uint16_t prev_i2c_switch = 0;
+
+    /* The device class need to be instantiated before this function called */
+    BUG_ON(fpgafwclass == NULL);
+
+    fpga_data = devm_kzalloc(&pdev->dev, sizeof(struct seastone2_fpga_data),
+                    GFP_KERNEL);
+
+    if (!fpga_data)
+        return -ENOMEM;
+
+    // Set default read address to VERSION
+    fpga_data->fpga_read_addr = fpga_dev.data_base_addr+FPGA_VERSION;
+    fpga_data->cpld1_read_addr = 0x00;
+    fpga_data->cpld2_read_addr = 0x00;
+
+    mutex_init(&fpga_data->fpga_lock);
+    for(ret=I2C_MASTER_CH_1 ;ret <= I2C_MASTER_CH_TOTAL; ret++){
+        mutex_init(&fpga_i2c_master_locks[ret-1]);
+    }
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (unlikely(!res)) {
+        printk(KERN_ERR "Specified Resource Not Available...\n");
+        kzfree(fpga_data);
+        return -1;
+    }
+
+    fpga = kobject_create_and_add("FPGA", &pdev->dev.kobj);
+    if (!fpga){
+        kzfree(fpga_data);
+        return -ENOMEM;
+    }
+
+    ret = sysfs_create_group(fpga, &fpga_attr_grp);
+    if (ret != 0) {
+        printk(KERN_ERR "Cannot create FPGA sysfs attributes\n");
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return ret;
+    }
+
+    cpld1 = kobject_create_and_add("CPLD1", &pdev->dev.kobj);
+    if (!cpld1){
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return -ENOMEM;
+    }
+    ret = sysfs_create_group(cpld1, &cpld1_attr_grp);
+    if (ret != 0) {
+        printk(KERN_ERR "Cannot create CPLD1 sysfs attributes\n");
+        kobject_put(cpld1);
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return ret;
+    }
+
+    cpld2 = kobject_create_and_add("CPLD2", &pdev->dev.kobj);
+    if (!cpld2){
+        sysfs_remove_group(cpld1, &cpld1_attr_grp);
+        kobject_put(cpld1);
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return -ENOMEM;
+    }
+    ret = sysfs_create_group(cpld2, &cpld2_attr_grp);
+    if (ret != 0) {
+        printk(KERN_ERR "Cannot create CPLD2 sysfs attributes\n");
+        kobject_put(cpld2);
+        sysfs_remove_group(cpld1, &cpld1_attr_grp);
+        kobject_put(cpld1);
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return ret;
+    }
+
+    sff_dev = device_create(fpgafwclass, NULL, MKDEV(0,0), NULL, "sff_device");
+    if (IS_ERR(sff_dev)){
+        printk(KERN_ERR "Failed to create sff device\n");
+        sysfs_remove_group(cpld2, &cpld2_attr_grp);
+        kobject_put(cpld2);
+        sysfs_remove_group(cpld1, &cpld1_attr_grp);
+        kobject_put(cpld1);
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return PTR_ERR(sff_dev);
+    }
+
+    ret = sysfs_create_group(&sff_dev->kobj, &sff_led_test_grp);
+    if (ret != 0) {
+        printk(KERN_ERR "Cannot create SFF attributes\n");
+        device_destroy(fpgafwclass, MKDEV(0,0));
+        sysfs_remove_group(cpld2, &cpld2_attr_grp);
+        kobject_put(cpld2);
+        sysfs_remove_group(cpld1, &cpld1_attr_grp);
+        kobject_put(cpld1);
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return ret;
+    }
+
+    ret = sysfs_create_link(&pdev->dev.kobj,&sff_dev->kobj,"SFF");
+    if (ret != 0){
+        sysfs_remove_group(&sff_dev->kobj, &sff_led_test_grp);
+        device_destroy(fpgafwclass, MKDEV(0,0));
+        sysfs_remove_group(cpld2, &cpld2_attr_grp);
+        kobject_put(cpld2);
+        sysfs_remove_group(cpld1, &cpld1_attr_grp);
+        kobject_put(cpld1);
+        sysfs_remove_group(fpga, &fpga_attr_grp);
+        kobject_put(fpga);
+        kzfree(fpga_data);
+        return ret;
+    }
+
+    for(portid_count=0 ; portid_count < VIRTUAL_I2C_PORT_LENGTH ; portid_count++){
+        fpga_data->i2c_adapter[portid_count] = seastone2_i2c_init(pdev, portid_count, VIRTUAL_I2C_BUS_OFFSET);
+    }
+
+
+    /* Init SFF devices */
+    for(portid_count=0; portid_count < SFF_PORT_TOTAL; portid_count++){
+        struct i2c_adapter *i2c_adap = fpga_data->i2c_adapter[portid_count];
+        if(i2c_adap){
+            fpga_data->sff_devices[portid_count] = seastone2_sff_init(portid_count);
+            struct sff_device_data *sff_data = dev_get_drvdata(fpga_data->sff_devices[portid_count]);
+            BUG_ON(sff_data == NULL);
+            if( sff_data->port_type == QSFP ){
+                fpga_data->sff_i2c_clients[portid_count] = i2c_new_device(i2c_adap, &sff8436_eeprom_info[0]);
+            }else{
+                fpga_data->sff_i2c_clients[portid_count] = i2c_new_device(i2c_adap, &sff8436_eeprom_info[1]);
+            }
+            sff_data = NULL;
+            sysfs_create_link(&fpga_data->sff_devices[portid_count]->kobj,
+                &fpga_data->sff_i2c_clients[portid_count]->dev.kobj,
+                "i2c");
+        }
+
+    }
+
+    printk(KERN_INFO "Virtual I2C buses created\n");
+
+#ifdef TEST_MODE
+    return 0;
+#endif
+    fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD1_SLAVE_ADDR,0x00,
+        I2C_SMBUS_READ,0x00,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&cpld1_version);
+    fpga_i2c_access(fpga_data->i2c_adapter[VIRTUAL_I2C_CPLD_INDEX],CPLD2_SLAVE_ADDR,0x00,
+        I2C_SMBUS_READ,0x00,I2C_SMBUS_BYTE_DATA,(union i2c_smbus_data*)&cpld2_version);
+
+    printk(KERN_INFO "CPLD1 VERSON: %2.2x\n", cpld1_version);
+    printk(KERN_INFO "CPLD2 VERSON: %2.2x\n", cpld2_version);
+
+    /* Init I2C buses that has PCA9548 switch device. */
+    for(portid_count = 0; portid_count < VIRTUAL_I2C_PORT_LENGTH; portid_count++){
+
+       struct i2c_dev_data *dev_data;
+       dev_data = i2c_get_adapdata(fpga_data->i2c_adapter[portid_count]);
+       unsigned char master_bus = dev_data->pca9548.master_bus;
+       unsigned char switch_addr = dev_data->pca9548.switch_addr;
+       unsigned char channel = dev_data->pca9548.channel;
+
+       if(switch_addr != 0xFF){
+
+           if(prev_i2c_switch != ( (master_bus << 8) | switch_addr) ){
+               // Found the bus with PCA9548, trying to clear all switch in it.
+               smbus_access(fpga_data->i2c_adapter[portid_count],switch_addr,0x00,I2C_SMBUS_WRITE,0x00,I2C_SMBUS_BYTE,NULL);
+               prev_i2c_switch = ( master_bus << 8 ) | switch_addr;
+           }
+       }
+    }
+    return 0;
+}
+
+static int seastone2_drv_remove(struct platform_device *pdev)
+{
+    int portid_count;
+    struct sff_device_data *rem_data;
+
+    for(portid_count=0; portid_count < SFF_PORT_TOTAL; portid_count++){
+        sysfs_remove_link(&fpga_data->sff_devices[portid_count]->kobj,"i2c");
+        i2c_unregister_device(fpga_data->sff_i2c_clients[portid_count]);
+    }
+
+    for(portid_count=0 ; portid_count < VIRTUAL_I2C_PORT_LENGTH ; portid_count++){
+        if(fpga_data->i2c_adapter[portid_count] != NULL){
+            info(KERN_INFO "<%x>",fpga_data->i2c_adapter[portid_count]);
+            i2c_del_adapter(fpga_data->i2c_adapter[portid_count]);
+        }
+    }
+
+    for (portid_count=0; portid_count < SFF_PORT_TOTAL; portid_count++){
+        if(fpga_data->sff_devices[portid_count] != NULL){
+            rem_data = dev_get_drvdata(fpga_data->sff_devices[portid_count]);
+            device_unregister(fpga_data->sff_devices[portid_count]);
+            put_device(fpga_data->sff_devices[portid_count]);
+            kfree(rem_data);
+        }
+    }
+
+    sysfs_remove_group(fpga, &fpga_attr_grp);
+    sysfs_remove_group(cpld1, &cpld1_attr_grp);
+    sysfs_remove_group(cpld2, &cpld2_attr_grp);
+    sysfs_remove_group(&sff_dev->kobj, &sff_led_test_grp);
+    kobject_put(fpga);
+    kobject_put(cpld1);
+    kobject_put(cpld2);
+    device_destroy(fpgafwclass, MKDEV(0,0));
+    devm_kfree(&pdev->dev, fpga_data);
+    return 0;
+}
+
+#ifdef TEST_MODE
+    #define FPGA_PCI_BAR_NUM 2
+#else
+    #define FPGA_PCI_BAR_NUM 0
+#endif
+
+
+
+static const struct pci_device_id fpga_id_table[] = {
+    {  PCI_VDEVICE(XILINX, FPGA_PCIE_DEVICE_ID) },
+    {  PCI_VDEVICE(TEST, TEST_PCIE_DEVICE_ID) },
+    {0, }
+};
+
+MODULE_DEVICE_TABLE(pci, fpga_id_table);
+
+static int fpga_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+    int err;
+    struct device *dev = &pdev->dev;
+        if ((err = pci_enable_device(pdev))) {
+        dev_err(dev, "pci_enable_device probe error %d for device %s\n",
+            err, pci_name(pdev));
+        return err;
+    }
+
+    if ((err = pci_request_regions(pdev, FPGA_PCI_NAME)) < 0) {
+        dev_err(dev, "pci_request_regions error %d\n", err);
+        goto pci_disable;
+    }
+
+    /* bar0: data mmio region */
+    fpga_dev.data_mmio_start = pci_resource_start(pdev, FPGA_PCI_BAR_NUM);
+    fpga_dev.data_mmio_len = pci_resource_len(pdev, FPGA_PCI_BAR_NUM);
+    fpga_dev.data_base_addr = pci_iomap(pdev, FPGA_PCI_BAR_NUM, 0);
+    if (!fpga_dev.data_base_addr) {
+        dev_err(dev, "cannot iomap region of size %lu\n",
+            (unsigned long)fpga_dev.data_mmio_len);
+        goto pci_release;
+    }
+    dev_info(dev, "data_mmio iomap base = 0x%lx \n",
+         (unsigned long)fpga_dev.data_base_addr);
+    dev_info(dev, "data_mmio_start = 0x%lx data_mmio_len = %lu\n",
+         (unsigned long)fpga_dev.data_mmio_start,
+         (unsigned long)fpga_dev.data_mmio_len);
+
+    printk(KERN_INFO "FPGA PCIe driver probe OK.\n");
+    printk(KERN_INFO "FPGA ioremap registers of size %lu\n",(unsigned long)fpga_dev.data_mmio_len);
+    printk(KERN_INFO "FPGA Virtual BAR %d at %8.8lx - %8.8lx\n",FPGA_PCI_BAR_NUM,(unsigned long)fpga_dev.data_base_addr,(unsigned long)fpga_dev.data_base_addr+ (unsigned long)fpga_dev.data_mmio_len);
+    printk(KERN_INFO "");
+    uint32_t buff = ioread32(fpga_dev.data_base_addr);
+    printk(KERN_INFO "FPGA VERSION : %8.8x\n", buff);
+    fpgafw_init();
+    return 0;
+
+reg_release:
+    pci_iounmap(pdev, fpga_dev.data_base_addr);
+pci_release:
+    pci_release_regions(pdev);
+pci_disable:
+    pci_disable_device(pdev);
+    return -EBUSY;
+}
+
+static void fpga_pci_remove(struct pci_dev *pdev)
+{
+    fpgafw_exit();
+    pci_iounmap(pdev, fpga_dev.data_base_addr);
+    pci_release_regions(pdev);
+    pci_disable_device(pdev);
+    printk(KERN_INFO "FPGA PCIe driver remove OK.\n");
+};
+
+static struct pci_driver pci_dev_ops = {
+    .name       = FPGA_PCI_NAME,
+    .probe      = fpga_pci_probe,
+    .remove     = fpga_pci_remove,
+    .id_table   = fpga_id_table,
+};
+
+
+static struct platform_driver seastone2_drv = {
+    .probe  = seastone2_drv_probe,
+    .remove = __exit_p(seastone2_drv_remove),
+    .driver = {
+        .name   = DRIVER_NAME,
+    },
+};
+
+enum{
+    READREG,
+    WRITEREG
+};
+
+struct fpga_reg_data {
+    uint32_t addr;
+    uint32_t value;
+};
+
+static long fpgafw_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg){
+    int ret = 0;
+    struct fpga_reg_data data;
+    mutex_lock(&fpga_data->fpga_lock);
+
+#ifdef TEST_MODE
+    static  uint32_t status_reg;
+#endif
+    // Switch function to read and write.
+    switch (cmd){
+        case READREG:
+            if (copy_from_user(&data, (void __user*)arg, sizeof(data)) != 0){
+                mutex_unlock(&fpga_data->fpga_lock);
+                return -EFAULT;
+            }
+            data.value = ioread32(fpga_dev.data_base_addr+data.addr);
+            if (copy_to_user((void __user*)arg ,&data, sizeof(data)) != 0){
+                mutex_unlock(&fpga_data->fpga_lock);
+                return -EFAULT;
+            }
+#ifdef TEST_MODE
+            if(data.addr == 0x1210){
+                switch (status_reg){
+                    case 0x0000 : status_reg=0x8000;
+                    break;
+
+                    case 0x8080 : status_reg=0x80C0;
+                    break;
+                    case 0x80C0 : status_reg=0x80F0;
+                    break;
+                    case 0x80F0 : status_reg=0x80F8;
+                    break;
+
+                }
+                iowrite32(status_reg,fpga_dev.data_base_addr+0x1210);
+            }
+#endif
+
+
+            break;
+        case WRITEREG:
+            if (copy_from_user(&data, (void __user*)arg, sizeof(data)) != 0){
+                mutex_unlock(&fpga_data->fpga_lock);
+                return -EFAULT;
+            }
+            iowrite32(data.value,fpga_dev.data_base_addr+data.addr);
+
+#ifdef TEST_MODE
+            if(data.addr == 0x1204){
+                status_reg=0x8080;
+                iowrite32(status_reg,fpga_dev.data_base_addr+0x1210);
+            }
+#endif
+
+            break;
+        default:
+            mutex_unlock(&fpga_data->fpga_lock);
+            return -EINVAL;
+    }
+    mutex_unlock(&fpga_data->fpga_lock);
+    return ret;
+}
+
+
+const struct file_operations fpgafw_fops = {
+    .owner      = THIS_MODULE,
+    .unlocked_ioctl = fpgafw_unlocked_ioctl,
+};
+
+
+static int fpgafw_init(void){
+   printk(KERN_INFO "Initializing the switchboard driver\n");
+   // Try to dynamically allocate a major number for the device -- more difficult but worth it
+   majorNumber = register_chrdev(0, DEVICE_NAME, &fpgafw_fops);
+   if (majorNumber<0){
+      printk(KERN_ALERT "Failed to register a major number\n");
+      return majorNumber;
+   }
+   printk(KERN_INFO "Device registered correctly with major number %d\n", majorNumber);
+
+   // Register the device class
+   fpgafwclass = class_create(THIS_MODULE, CLASS_NAME);
+   if (IS_ERR(fpgafwclass)){                // Check for error and clean up if there is
+      unregister_chrdev(majorNumber, DEVICE_NAME);
+      printk(KERN_ALERT "Failed to register device class\n");
+      return PTR_ERR(fpgafwclass);          // Correct way to return an error on a pointer
+   }
+   printk(KERN_INFO "Device class registered correctly\n");
+
+   // Register the device driver
+   fpgafwdev = device_create(fpgafwclass, NULL, MKDEV(majorNumber, 0), NULL, DEVICE_NAME);
+   if (IS_ERR(fpgafwdev)){               // Clean up if there is an error
+      class_destroy(fpgafwclass);           // Repeated code but the alternative is goto statements
+      unregister_chrdev(majorNumber, DEVICE_NAME);
+      printk(KERN_ALERT "Failed to create the FW upgrade device node\n");
+      return PTR_ERR(fpgafwdev);
+   }
+   printk(KERN_INFO "FPGA fw upgrade device node created correctly\n"); // Made it! device was initialized
+   return 0;
+}
+
+static void fpgafw_exit(void){
+   device_destroy(fpgafwclass, MKDEV(majorNumber, 0));     // remove the device
+   class_unregister(fpgafwclass);                          // unregister the device class
+   class_destroy(fpgafwclass);                             // remove the device class
+   unregister_chrdev(majorNumber, DEVICE_NAME);            // unregister the major number
+   printk(KERN_INFO "Goodbye!\n");
+}
+
+int seastone2_init(void)
+{
+    int rc;
+    rc = pci_register_driver(&pci_dev_ops);
+    if (rc)
+        return rc;
+    if(fpga_dev.data_base_addr == NULL){
+        printk(KERN_ALERT "FPGA PCIe device not found!\n");
+        return -ENODEV;
+    }
+    platform_device_register(&seastone2_dev);
+    platform_driver_register(&seastone2_drv);
+    return 0;
+}
+
+void seastone2_exit(void)
+{
+    platform_driver_unregister(&seastone2_drv);
+    platform_device_unregister(&seastone2_dev);
+    pci_unregister_driver(&pci_dev_ops);
+}
+
+module_init(seastone2_init);
+module_exit(seastone2_exit);
+
+MODULE_AUTHOR("Pradchaya P. pphuhcar@celestica.com");
+#ifdef SEASTONE2
+MODULE_DESCRIPTION("Celestica seastone2 platform driver");
+#else
+MODULE_DESCRIPTION("Celestica questone2 platform driver");
+#endif
+MODULE_VERSION(MOD_VERSION);
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff-8436.h b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff-8436.h
new file mode 100644
index 000000000000..3f8f00f4dcd0
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff-8436.h
@@ -0,0 +1,31 @@
+#ifndef _LINUX_SFF_8436_H
+#define _LINUX_SFF_8436_H
+
+#include <linux/types.h>
+#include <linux/memory.h>
+
+/*
+ * As seen through Linux I2C, differences between the most common types of I2C
+ * memory include:
+ * - How much memory is available (usually specified in bit)?
+ * - What write page size does it support?
+ * - Special flags (read_only, world readable...)?
+ *
+ * If you set up a custom eeprom type, please double-check the parameters.
+ * Especially page_size needs extra care, as you risk data loss if your value
+ * is bigger than what the chip actually supports!
+ */
+
+struct sff_8436_platform_data {
+	u32		byte_len;		/* size (sum of all addr) */
+	u16		page_size;		/* for writes */
+	u8		flags;
+#define SFF_8436_FLAG_READONLY	0x40	/* sysfs-entry will be read-only */
+#define SFF_8436_FLAG_IRUGO		0x20	/* sysfs-entry will be world-readable */
+#define SFF_8436_FLAG_TAKE8ADDR	0x10	/* take always 8 addresses (24c00) */
+
+	//void		(*setup)(struct memory_accessor *, void *context);
+	//void		*context;
+};
+
+#endif /* _LINUX_SFF_8436_H */
diff --git a/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff_8436_eeprom.c b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff_8436_eeprom.c
new file mode 100644
index 000000000000..6779ccee5e5e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/modules/builds/src/sff_8436_eeprom.c
@@ -0,0 +1,982 @@
+/*
+ * sff_8436_eeprom.c - handle most SFF-8436 based QSFP EEPROMs
+ *
+ * Copyright (C) 2014 Cumulus networks Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Freeoftware Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/*
+ * 	Description:
+ * 	a) SFF 8436 based qsfp read/write transactions are just like the at24 eeproms
+ * 	b) The register/memory layout is up to 5 128 byte pages defined by a "pages valid"
+ * 		register and switched via a "page select" register as explained in below diagram.
+ * 	c) 256 bytes are mapped at a time. page 0 is always mapped to the first 128 bytes and
+ * 	   the other 4 pages are selectively mapped to the second 128 bytes
+ *
+ *	                    SFF 8436 based QSFP Memory Map
+ *
+ *	                    2-Wire Serial Address: 1010000x
+ *
+ *	                    Lower Page 00h (128 bytes)
+ *	                    =====================
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |                     |
+ *	                   |Page Select Byte(127)|
+ *	                    =====================
+ *	                              |
+ *	                              |
+ *	                              |
+ *	                              |
+ *	                              V
+ *	     -----------------------------------------------------------------
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    |                  |                    |                         |
+ *	    V                  V                    V                         V
+ *	 -------------   ----------------      -----------------     --------------
+ *	|             | |                |    |                 |   |              |
+ *	|   Upper     | |     Upper      |    |     Upper       |   |    Upper     |
+ *	|  Page 00h   | |    Page 01h    |    |    Page 02h     |   |   Page 03h   |
+ *	|             | |   (Optional)   |    |   (Optional)    |   |  (Optional   |
+ *	|             | |                |    |                 |   |   for Cable  |
+ *	|             | |                |    |                 |   |  Assemblies) |
+ *	|    ID       | |     AST        |    |      User       |   |              |
+ *	|  Fields     | |    Table       |    |   EEPROM Data   |   |              |
+ *	|             | |                |    |                 |   |              |
+ *	|             | |                |    |                 |   |              |
+ *	|             | |                |    |                 |   |              |
+ *	 -------------   ----------------      -----------------     --------------
+ *
+ *
+ **/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/mod_devicetable.h>
+#include <linux/log2.h>
+#include <linux/bitops.h>
+#include <linux/jiffies.h>
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include "sff-8436.h"
+
+#include <linux/types.h>
+#include <linux/memory.h>
+
+#define SFF_8436_EEPROM_SIZE       5*128
+#define SFF_8436_MAX_PAGE_COUNT    5
+#define SFF_8436_MMAP_SIZE         256
+#define SFF_8436_PAGE_SELECT_REG   0x7F
+
+#define  SFF_8436_OPTION_4_OFFSET           0xC3
+#define   SFF_8436_PAGE_02_PRESENT          (1 << 7) /* Memory Page 02 present */
+#define   SFF_8436_PAGE_01_PRESENT          (1 << 6) /* Memory Page 01 present */
+#define  SFF_8436_STATUS_2_OFFSET           0x02
+#define   SFF_8436_STATUS_PAGE_03_PRESENT_L  (1 << 2) /* Flat Memory:0- Paging, 1- Page 0 only */
+
+struct sff_8436_data {
+	struct sff_8436_platform_data chip;
+	//struct memory_accessor macc;
+	int use_smbus;
+
+	/*
+	 * Lock protects against activities from other Linux tasks,
+	 * but not from changes by other I2C masters.
+	 */
+	struct mutex lock;
+	struct bin_attribute bin;
+
+	u8 *writebuf;
+	unsigned write_max;
+
+	unsigned num_addresses;
+
+	u8  data[SFF_8436_EEPROM_SIZE];
+
+	struct i2c_client *client[];
+};
+
+typedef enum qsfp_opcode {
+    QSFP_READ_OP = 0,
+    QSFP_WRITE_OP = 1
+} qsfp_opcode_e;
+
+/*
+ * This parameter is to help this driver avoid blocking other drivers out
+ * of I2C for potentially troublesome amounts of time. With a 100 kHz I2C
+ * clock, one 256 byte read takes about 1/43 second which is excessive;
+ * but the 1/170 second it takes at 400 kHz may be quite reasonable; and
+ * at 1 MHz (Fm+) a 1/430 second delay could easily be invisible.
+ *
+ * This value is forced to be a power of two so that writes align on pages.
+ */
+static unsigned io_limit = 128;
+
+/*
+ *pecs often allow 5 msec for a page write, sometimes 20 msec;
+ * it's important to recover from write timeouts.
+ */
+static unsigned write_timeout = 25;
+
+#define SFF_8436_PAGE_SIZE 128
+#define SFF_8436_SIZE_BYTELEN 5
+#define SFF_8436_SIZE_FLAGS 8
+
+#define SFF_8436_BITMASK(x) (BIT(x) - 1)
+
+
+/* create non-zero magic value for given eeprom parameters */
+#define SFF_8436_DEVICE_MAGIC(_len, _flags) 		\
+	((1 << SFF_8436_SIZE_FLAGS | (_flags)) 		\
+	    << SFF_8436_SIZE_BYTELEN | ilog2(_len))
+
+static const struct i2c_device_id sff8436_ids[] = {
+	{ "sff8436",SFF_8436_DEVICE_MAGIC(2048 / 8, 0) },
+	{ /* END OF LIST */ }
+};
+MODULE_DEVICE_TABLE(i2c, sff8436_ids);
+
+/*-------------------------------------------------------------------------*/
+/*
+ * This routine computes the addressing information to be used for a given r/w request.
+ * Assumes that sanity checks for offset happened at sysfs-layer.
+ * Offset within Lower Page 00h and Upper Page 00h are not recomputed
+ */
+static uint8_t sff_8436_translate_offset(struct sff_8436_data *sff_8436,
+		loff_t *offset)
+{
+	unsigned page = 0;
+
+	if (*offset < SFF_8436_MMAP_SIZE) {
+		return 0;
+	}
+
+	page = (*offset >> 7)-1;
+
+	if (page > 0 ) {
+		*offset = 0x80 + (*offset & 0x7f);
+	} else {
+		*offset &= 0xff;
+	}
+
+	return page;
+}
+
+static int sff_8436_read_reg(struct sff_8436_data *sff_8436,
+                  uint8_t reg, uint8_t *val)
+{
+	int count = 1, i = 0;
+	struct i2c_client *client = sff_8436->client[0];
+	struct i2c_msg msg[2];
+	u8 msgbuf[2];
+	ssize_t status;
+	unsigned long timeout, read_time;
+
+	memset(msg, 0, sizeof(msg));
+
+	/*
+	 * Writes fail if the previous one didn't complete yet. We may
+	 * loop a few times until this one succeeds, waiting at least
+	 * long enough for one entire page write to work.
+	 */
+	timeout = jiffies + msecs_to_jiffies(write_timeout);
+	do {
+		read_time = jiffies;
+		switch (sff_8436->use_smbus) {
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			status = i2c_smbus_read_i2c_block_data(client,
+					reg, count, val);
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			status = i2c_smbus_read_word_data(client, reg);
+
+			if (status >= 0) {
+				*val = status & 0xff;
+				status = count;
+			}
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			status = i2c_smbus_read_byte_data(client, reg);
+
+			if (status >= 0) {
+				*val = status;
+				status = count;
+			}
+			break;
+
+		default:
+            i = 0;
+			msgbuf[i++] = reg;
+
+			msg[0].addr = client->addr;
+			msg[0].buf = msgbuf;
+			msg[0].len = i;
+
+			msg[1].addr = client->addr;
+			msg[1].flags = I2C_M_RD;
+			msg[1].buf = val;
+			msg[1].len = count;
+
+			status = i2c_transfer(client->adapter, msg, 2);
+			if (status == 2)
+				status = count;
+			break;
+		}
+		dev_dbg(&client->dev, "read (using smbus %d) %d@%d --> %zd (%ld)\n",
+				sff_8436->use_smbus, count, reg, status, jiffies);
+
+		if (status == count)
+			return count;
+
+		/* REVISIT: at HZ=100, this is sloooow */
+		msleep(1);
+	} while (time_before(read_time, timeout));
+
+	return -ETIMEDOUT;
+}
+
+static int sff_8436_write_reg(struct sff_8436_data *sff_8436,
+                  uint8_t reg, uint8_t val)
+{
+	uint8_t data[2] = { reg, val };
+	int count = 1;
+	struct i2c_client *client = sff_8436->client[0];
+	struct i2c_msg msg;
+	ssize_t status;
+	unsigned long timeout, write_time;
+
+	/*
+	 * Writes fail if the previous one didn't complete yet. We may
+	 * loop a few times until this one succeeds, waiting at least
+	 * long enough for one entire page write to work.
+	 */
+	timeout = jiffies + msecs_to_jiffies(write_timeout);
+	do {
+		write_time = jiffies;
+		switch (sff_8436->use_smbus) {
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			status = i2c_smbus_write_i2c_block_data(client,
+					reg, count, &val);
+			if (status == 0)
+				status = count;
+			break;
+		case I2C_SMBUS_WORD_DATA:
+		case I2C_SMBUS_BYTE_DATA:
+			status = i2c_smbus_write_byte_data(client, reg,  val);
+
+			if (status == 0)
+				status = count;
+			break;
+		default:
+			msg.addr = client->addr;
+			msg.flags = 0;
+			msg.len = sizeof(data);
+			msg.buf = (char *) data;
+
+			status = i2c_transfer(client->adapter, &msg, 1);
+			if (status == 1)
+				status = count;
+			break;
+		}
+		dev_dbg(&client->dev, "write (using smbus %d) %d@%d --> %zd (%ld)\n",
+				sff_8436->use_smbus, count, reg, status, jiffies);
+
+		if (status == count)
+			return count;
+
+		/* REVISIT: at HZ=100, this is sloooow */
+		msleep(1);
+	} while (time_before(write_time, timeout));
+
+	return -ETIMEDOUT;
+}
+
+static int sff_8436_write_page_reg(struct sff_8436_data *sff_8436,
+                               uint8_t val)
+{
+	return sff_8436_write_reg(sff_8436, SFF_8436_PAGE_SELECT_REG, val);
+}
+
+static ssize_t sff_8436_eeprom_read(struct sff_8436_data *sff_8436, char *buf,
+		    unsigned offset, size_t count)
+{
+	struct i2c_msg msg[2];
+	u8 msgbuf[2];
+	struct i2c_client *client = sff_8436->client[0];
+	unsigned long timeout, read_time;
+	int status, i;
+
+	memset(msg, 0, sizeof(msg));
+
+	switch (sff_8436->use_smbus) {
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		/*smaller eeproms can work given some SMBus extension calls */
+		if (count > I2C_SMBUS_BLOCK_MAX)
+			count = I2C_SMBUS_BLOCK_MAX;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		/* Check for odd length transaction */
+		count = (count == 1) ? 1 : 2;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		count = 1;
+		break;
+	default:
+		/*
+		 * When we have a better choice than SMBus calls, use a
+		 * combined I2C message. Write address; then read up to
+		 * io_limit data bytes. Note that read page rollover helps us
+		 * here (unlike writes). msgbuf is u8 and will cast to our
+		 * needs.
+		 */
+		i = 0;
+		msgbuf[i++] = offset;
+
+		msg[0].addr = client->addr;
+		msg[0].buf = msgbuf;
+		msg[0].len = i;
+
+		msg[1].addr = client->addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].buf = buf;
+		msg[1].len = count;
+	}
+
+	/*
+	 * Reads fail if the previous write didn't complete yet. We may
+	 * loop a few times until this one succeeds, waiting at least
+	 * long enough for one entire page write to work.
+	 */
+	timeout = jiffies + msecs_to_jiffies(write_timeout);
+	do {
+		read_time = jiffies;
+
+		switch (sff_8436->use_smbus) {
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			status = i2c_smbus_read_i2c_block_data(client, offset,
+					count, buf);
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			status = i2c_smbus_read_word_data(client, offset);
+			if (status >= 0) {
+				buf[0] = status & 0xff;
+				if (count == 2)
+					buf[1] = status >> 8;
+				status = count;
+			}
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			status = i2c_smbus_read_byte_data(client, offset);
+			if (status >= 0) {
+				buf[0] = status;
+				status = count;
+			}
+			break;
+		default:
+			status = i2c_transfer(client->adapter, msg, 2);
+			if (status == 2)
+				status = count;
+		}
+
+		dev_dbg(&client->dev, "eeprom read %zu@%d --> %d (%ld)\n",
+				count, offset, status, jiffies);
+
+		if (status == count)
+			return count;
+
+		/* REVISIT: at HZ=100, this is sloooow */
+		msleep(1);
+	} while (time_before(read_time, timeout));
+
+	return -ETIMEDOUT;
+}
+
+static ssize_t sff_8436_eeprom_write(struct sff_8436_data *sff_8436, const char *buf,
+		    unsigned offset, size_t count)
+{
+	struct i2c_client *client = sff_8436->client[0];
+	struct i2c_msg msg;
+	unsigned long timeout, write_time;
+	unsigned next_page;
+	int status, i = 0;
+
+	/* write max is at most a page */
+	if (count > sff_8436->write_max)
+		count = sff_8436->write_max;
+
+		/* Never roll over backwards, to the start of this page */
+	next_page = roundup(offset + 1, SFF_8436_PAGE_SIZE);
+	if (offset + count > next_page)
+		count = next_page - offset;
+
+	switch (sff_8436->use_smbus) {
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		/*smaller eeproms can work given some SMBus extension calls */
+		if (count > I2C_SMBUS_BLOCK_MAX)
+			count = I2C_SMBUS_BLOCK_MAX;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		/* Check for odd length transaction */
+		count = (count == 1) ? 1 : 2;
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		count = 1;
+		break;
+	default:
+		/* If we'll use I2C calls for I/O, set up the message */
+		msg.addr = client->addr;
+		msg.flags = 0;
+
+		/* msg.buf is u8 and casts will mask the values */
+		msg.buf = sff_8436->writebuf;
+
+		msg.buf[i++] = offset;
+		memcpy(&msg.buf[i], buf, count);
+		msg.len = i + count;
+		break;
+	}
+
+	/*
+	 * Reads fail if the previous write didn't complete yet. We may
+	 * loop a few times until this one succeeds, waiting at least
+	 * long enough for one entire page write to work.
+	 */
+	timeout = jiffies + msecs_to_jiffies(write_timeout);
+	do {
+		write_time = jiffies;
+
+		switch (sff_8436->use_smbus) {
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			status = i2c_smbus_write_i2c_block_data(client,
+			              offset, count, buf);
+			if (status == 0)
+				status = count;
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			if (count == 2) {
+				status = i2c_smbus_write_word_data(
+				            client,offset,(u16)((buf[0]) |
+				            (buf[1] << 8)));
+			} else {
+					/* count = 1 */
+					status = i2c_smbus_write_byte_data(
+					           client, offset, buf[0]);
+			}
+			if (status == 0)
+				status = count;
+			break;
+		case I2C_SMBUS_BYTE_DATA:
+			status = i2c_smbus_write_byte_data(client, offset,  buf[0]);
+			if (status == 0)
+				status = count;
+			break;
+		default:
+			status = i2c_transfer(client->adapter, &msg, 1);
+			if (status == 1)
+				status = count;
+			break;
+		}
+
+		dev_dbg(&client->dev, "eeprom write %zu@%d --> %d (%ld)\n",
+				count, offset, status, jiffies);
+
+		if (status == count)
+			return count;
+
+		/* REVISIT: at HZ=100, this is sloooow */
+		msleep(1);
+	} while (time_before(write_time, timeout));
+
+	return -ETIMEDOUT;
+}
+
+static ssize_t sff_8436_eeprom_update_client(struct sff_8436_data *sff_8436,
+                                loff_t off, size_t count, qsfp_opcode_e opcode)
+{
+	struct i2c_client *client = sff_8436->client[0];
+	ssize_t retval = 0;
+	u8 page = 0;
+	loff_t phy_offset = off;
+	int ret = 0;
+
+	page = sff_8436_translate_offset(sff_8436, &phy_offset);
+
+	dev_dbg(&client->dev,
+					"sff_8436_eeprom_update_client off %lld  page:%d phy_offset:%lld, count:%zu, opcode:%d\n",
+					off, page, phy_offset, count, opcode);
+	if (page > 0) {
+		ret = sff_8436_write_page_reg(sff_8436, page);
+		if (ret < 0) {
+			dev_err(&client->dev,
+					"sff_8436_write_page_reg for page %d failed ret:%d!\n",
+					page, ret);
+			return ret;
+		}
+	}
+
+	while (count) {
+		ssize_t	status;
+
+		if (opcode == QSFP_READ_OP) {
+			status =  sff_8436_eeprom_read(sff_8436, (char *)(&sff_8436->data[off]), phy_offset, count);
+		} else {
+			status =  sff_8436_eeprom_write(sff_8436, (char *)(&sff_8436->data[off]), phy_offset, count);
+		}
+		if (status <= 0) {
+			if (retval == 0)
+				retval = status;
+			break;
+		}
+		phy_offset += status;
+		off += status;
+		count -= status;
+		retval += status;
+	}
+
+
+	if (page > 0) {
+		ret = sff_8436_write_page_reg(sff_8436, 0);
+		if (ret < 0) {
+			dev_err(&client->dev,
+					"sff_8436_write_page_reg for page 0 failed ret:%d!\n", ret);
+			return ret;
+		}
+	}
+	return retval;
+}
+
+static ssize_t sff_8436_read_write(struct sff_8436_data *sff_8436,
+		char *buf, loff_t off, size_t len, qsfp_opcode_e opcode)
+{
+	struct i2c_client *client = sff_8436->client[0];
+	u8 page;
+	u8 refresh_page = 0;
+	int ret = 0;
+	u8 val = 0;
+	int err_timeout = 0;
+	size_t pending_len = 0, page_len = 0;
+	loff_t page_offset = 0, page_start_offset = 0;
+
+	if (unlikely(!len))
+		return len;
+
+	if (off > SFF_8436_EEPROM_SIZE)
+		return 0;
+
+	if (off + len > SFF_8436_EEPROM_SIZE)
+		len = SFF_8436_EEPROM_SIZE - off;
+
+	if (opcode == QSFP_READ_OP) {
+		memset(sff_8436->data, 0xff, SFF_8436_EEPROM_SIZE);
+	} else if (opcode == QSFP_WRITE_OP) {
+		memcpy(&sff_8436->data[off], buf, len);
+	}
+
+	/*
+	 * Read data from chip, protecting against concurrent updates
+	 * from this host, but not from other I2C masters.
+	 */
+	mutex_lock(&sff_8436->lock);
+
+	/*
+	 * Refresh pages which covers the requested data
+	 * from offset to  off + len
+	 * Only refresh pages which contain requested bytes
+	 *
+	 */
+
+	pending_len = len;
+
+	for (page = off >> 7; page <= (off + len - 1) >> 7; page++) {
+		refresh_page = 0;
+		switch (page) {
+		case 0:
+			/* Lower page 00h */
+			refresh_page = 1;
+			err_timeout = 1;
+			break;
+		case 1:
+			/* Upper page 00h */
+			refresh_page = 1;
+			err_timeout = 1;
+			break;
+		case 2:
+			/* Upper page 01h */
+			ret = sff_8436_read_reg(sff_8436, SFF_8436_OPTION_4_OFFSET, &val);
+			if (ret < 0)  {
+				dev_dbg(&client->dev,
+				"sff_8436_read_reg for page 01h status failed %d!\n", ret);
+				goto err;
+			}
+			if (val & SFF_8436_PAGE_01_PRESENT) {
+				refresh_page = 1;
+			}
+			break;
+		case 3:
+			/* Upper page 02h */
+			ret = sff_8436_read_reg(sff_8436, SFF_8436_OPTION_4_OFFSET, &val);
+			if (ret < 0)  {
+				dev_dbg(&client->dev,
+				"sff_8436_read_reg for page 02h status failed %d!\n", ret);
+				goto err;
+			}
+			if (val & SFF_8436_PAGE_02_PRESENT) {
+				refresh_page = 1;
+			}
+			break;
+		case 4:
+			/* Upper page 03h */
+			ret = sff_8436_read_reg(sff_8436, SFF_8436_STATUS_2_OFFSET, &val);
+			if (ret < 0)  {
+				dev_dbg(&client->dev,
+				"sff_8436_read_reg for page 03h status failed %d!\n", ret);
+				goto err;
+			}
+			if (!(val & SFF_8436_STATUS_PAGE_03_PRESENT_L)) {
+				refresh_page = 1;
+			}
+			break;
+		default:
+			/* Invalid page index */
+			dev_err(&client->dev, "Invalid page %d!\n", page);
+			ret = -EINVAL;
+			goto err;
+		}
+
+		if (!refresh_page) {
+			/* if page is not valid or already refreshed */
+			continue;
+		}
+
+		/*
+		 * Compute the offset and number of bytes to be read/write
+		 * w.r.t requested page
+		 *
+		 * 1. start at offset 0 (within the page), and read/write the entire page
+		 * 2. start at offset 0 (within the page) and read/write less than entire page
+		 * 3. start at an offset not equal to 0 and read/write the rest of the page
+		 * 4. start at an offset not equal to 0 and read/write less than (end of page - offset)
+		 *
+		 */
+		page_start_offset = page * SFF_8436_PAGE_SIZE;
+
+		if (page_start_offset < off) {
+			page_offset = off;
+			if (off + pending_len < page_start_offset + SFF_8436_PAGE_SIZE) {
+				page_len = pending_len;
+			} else {
+				page_len = SFF_8436_PAGE_SIZE - off;
+			}
+		} else {
+			page_offset = page_start_offset;
+			if (pending_len > SFF_8436_PAGE_SIZE) {
+				page_len = SFF_8436_PAGE_SIZE;
+			} else {
+				page_len = pending_len;
+			}
+		}
+
+		pending_len = pending_len - page_len;
+
+		dev_dbg(&client->dev,
+				"sff_read off %lld len %zu page_start_offset %lld page_offset %lld page_len %zu pending_len %zu\n",
+				off, len, page_start_offset, page_offset, page_len, pending_len);
+
+		/* Refresh the data from offset for specified len */
+		ret = sff_8436_eeprom_update_client(sff_8436, page_offset, page_len, opcode);
+		if (ret != page_len) {
+			if (err_timeout) {
+				dev_dbg(&client->dev, "sff_8436_update_client for %s page %d page_offset %lld page_len %zu failed %d!\n",
+							(page ? "Upper" : "Lower"), (page ? (page-1) : page), page_offset, page_len, ret);
+				goto err;
+			} else {
+				dev_err(&client->dev, "sff_8436_update_client for %s page %d page_offset %lld page_len %zu failed %d!\n",
+							(page ? "Upper" : "Lower"), (page ? (page-1) : page), page_offset, page_len, ret);
+			}
+		}
+	}
+	mutex_unlock(&sff_8436->lock);
+
+	if (opcode == QSFP_READ_OP) {
+		memcpy(buf, &sff_8436->data[off], len);
+	}
+	return len;
+
+err:
+	mutex_unlock(&sff_8436->lock);
+
+	return ret;
+}
+
+static ssize_t sff_8436_bin_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+	struct sff_8436_data *sff_8436 = i2c_get_clientdata(client);
+
+	return sff_8436_read_write(sff_8436, buf, off, count, QSFP_READ_OP);
+}
+
+
+static ssize_t sff_8436_bin_write(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+	struct sff_8436_data *sff_8436 = i2c_get_clientdata(client);
+
+	return sff_8436_read_write(sff_8436, buf, off, count, QSFP_WRITE_OP);
+}
+/*-------------------------------------------------------------------------*/
+
+/*
+ * This lets other kernel code access the eeprom data. For example, it
+ * might hold a board's Ethernet address, or board-specific calibration
+ * data generated on the manufacturing floor.
+ */
+
+// static ssize_t sff_8436_macc_read(struct memory_accessor *macc, char *buf,
+// 			 off_t offset, size_t count)
+// {
+// 	struct sff_8436_data *sff_8436 = container_of(macc, struct sff_8436_data, macc);
+
+// 	return sff_8436_read_write(sff_8436, buf, offset, count, QSFP_READ_OP);
+// }
+
+// static ssize_t sff_8436_macc_write(struct memory_accessor *macc, const char *buf,
+//              off_t offset, size_t count)
+// {
+// 	struct sff_8436_data *sff_8436 = container_of(macc, struct sff_8436_data, macc);
+
+// 	return sff_8436_read_write(sff_8436, buf, offset, count, QSFP_WRITE_OP);
+// }
+
+/*-------------------------------------------------------------------------*/
+
+static int sff_8436_remove(struct i2c_client *client)
+{
+	struct sff_8436_data *sff_8436;
+
+	sff_8436 = i2c_get_clientdata(client);
+	sysfs_remove_bin_file(&client->dev.kobj, &sff_8436->bin);
+
+	kfree(sff_8436->writebuf);
+	kfree(sff_8436);
+	return 0;
+}
+static int sff_8436_eeprom_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	int use_smbus = 0;
+	struct sff_8436_platform_data chip;
+	struct sff_8436_data *sff_8436;
+	kernel_ulong_t magic;
+
+	if (client->dev.platform_data) {
+		chip = *(struct sff_8436_platform_data *)client->dev.platform_data;
+	} else {
+		/*
+		 * SFF-8436 MMAP is 256 bytes long
+		 */
+		magic = SFF_8436_DEVICE_MAGIC(2048 / 8, 0);
+		chip.byte_len = BIT(magic & SFF_8436_BITMASK(SFF_8436_SIZE_BYTELEN));
+		magic >>= SFF_8436_SIZE_BYTELEN;
+		chip.flags = magic & SFF_8436_BITMASK(SFF_8436_SIZE_FLAGS);
+		/*
+		 * This is slow, but we can't know all eeproms, so we better
+		 * play safe.pecifying custom eeprom-types via platform_data
+		 * is recommended anyhow.
+		 */
+		chip.page_size = 1;
+
+		//chip.setup = NULL;
+		//chip.context = NULL;
+	}
+
+	if (!is_power_of_2(chip.byte_len))
+		dev_warn(&client->dev,
+			"byte_len looks suspicious (no power of 2)!\n");
+
+	if (!chip.page_size) {
+		dev_err(&client->dev, "page_size must not be 0!\n");
+		err = -EINVAL;
+		goto exit;
+	}
+	if (!is_power_of_2(chip.page_size))
+		dev_warn(&client->dev,
+			"page_size looks suspicious (no power of 2)!\n");
+
+	/* Use I2C operations unless we're stuck with SMBus extensions. */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		if (i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {
+			use_smbus = I2C_SMBUS_I2C_BLOCK_DATA;
+		} else if (i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_WORD_DATA)) {
+			use_smbus = I2C_SMBUS_WORD_DATA;
+		} else if (i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_READ_BYTE_DATA)) {
+			use_smbus = I2C_SMBUS_BYTE_DATA;
+		} else {
+			err = -EPFNOSUPPORT;
+			goto exit;
+		}
+	}
+
+	if (!(sff_8436 = kzalloc(sizeof(struct sff_8436_data) +  sizeof(struct i2c_client *), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	mutex_init(&sff_8436->lock);
+	sff_8436->use_smbus = use_smbus;
+	sff_8436->chip = chip;
+
+	/*
+	 * Export the EEPROM bytes through sysfs, since that's convenient.
+	 * By default, only root should see the data (maybe passwords etc)
+	 */
+	sysfs_bin_attr_init(&sff_8436->bin);
+	sff_8436->bin.attr.name = "eeprom";
+	sff_8436->bin.attr.mode = SFF_8436_FLAG_IRUGO;
+	sff_8436->bin.read = sff_8436_bin_read;
+	sff_8436->bin.size = SFF_8436_EEPROM_SIZE;
+
+	//sff_8436->macc.read = sff_8436_macc_read;
+
+	if (!use_smbus ||
+			(i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) ||
+			i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_WRITE_WORD_DATA) ||
+			i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
+		//unsigned write_max = chip.page_size;
+		/*
+		 * NOTE: AN-2079
+		 * Finisar recommends that the host implement 1 byte writes only,
+		 * since this module only supports 32 byte page boundaries.
+		 * 2 byte writes are acceptable for PE and Vout changes per
+		 * Application Note AN-2071.
+		 */
+		unsigned write_max = 1;
+
+		//sff_8436->macc.write = sff_8436_macc_write;
+
+		sff_8436->bin.write = sff_8436_bin_write;
+		sff_8436->bin.attr.mode |= S_IWUSR;
+
+		if (write_max > io_limit)
+			write_max = io_limit;
+		if (use_smbus && write_max > I2C_SMBUS_BLOCK_MAX)
+			write_max = I2C_SMBUS_BLOCK_MAX;
+		sff_8436->write_max = write_max;
+
+		/* buffer (data + address at the beginning) */
+		sff_8436->writebuf = kmalloc(write_max + 2, GFP_KERNEL);
+		if (!sff_8436->writebuf) {
+			err = -ENOMEM;
+			goto exit_kfree;
+		}
+	} else {
+			dev_warn(&client->dev,
+				"cannot write due to controller restrictions.");
+	}
+
+	memset(sff_8436->data, 0xff, SFF_8436_EEPROM_SIZE);
+
+	sff_8436->client[0] = client;
+
+	/* create the sysfs eeprom file */
+	err = sysfs_create_bin_file(&client->dev.kobj, &sff_8436->bin);
+	if (err)
+		goto err_struct;
+
+	i2c_set_clientdata(client, sff_8436);
+
+	dev_info(&client->dev, "%zu byte %s EEPROM, %s\n",
+		sff_8436->bin.size, client->name,
+		"read-only");
+
+	if (use_smbus == I2C_SMBUS_WORD_DATA ||
+	    use_smbus == I2C_SMBUS_BYTE_DATA) {
+		dev_notice(&client->dev, "Falling back to %s reads, "
+			   "performance will suffer\n", use_smbus ==
+			   I2C_SMBUS_WORD_DATA ? "word" : "byte");
+	}
+
+	//if (chip.setup)
+		//chip.setup(&sff_8436->macc, chip.context);
+
+	return 0;
+
+err_sysfs_cleanup:
+	sysfs_remove_bin_file(&client->dev.kobj, &sff_8436->bin);
+err_struct:
+	kfree(sff_8436->writebuf);
+exit_kfree:
+	kfree(sff_8436);
+exit:
+	dev_dbg(&client->dev, "probe error %d\n", err);
+
+	return err;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct i2c_driver sff_8436_driver = {
+	.driver = {
+		.name = "sff8436",
+		.owner = THIS_MODULE,
+	},
+	.probe = sff_8436_eeprom_probe,
+	.remove = sff_8436_remove,
+	.id_table = sff8436_ids,
+};
+
+static int __init sff_8436_init(void)
+{
+	if (!io_limit) {
+		pr_err("sff_8436: io_limit must not be 0!\n");
+		return -EINVAL;
+	}
+
+	io_limit = rounddown_pow_of_two(io_limit);
+	return i2c_add_driver(&sff_8436_driver);
+}
+module_init(sff_8436_init);
+
+static void __exit sff_8436_exit(void)
+{
+	i2c_del_driver(&sff_8436_driver);
+}
+module_exit(sff_8436_exit);
+
+MODULE_DESCRIPTION("Driver for SFF-8436 based QSFP EEPROMs");
+MODULE_AUTHOR("VIDYA RAVIPATI <vidya@cumulusnetworks.com>");
+MODULE_LICENSE("GPL");
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/Makefile b/packages/platforms/celestica/x86-64/questone-2a/onlp/Makefile
new file mode 100644
index 000000000000..003238cf6d4e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/Makefile
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/PKG.yml b/packages/platforms/celestica/x86-64/questone-2a/onlp/PKG.yml
new file mode 100644
index 000000000000..1208b9f8e95e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/PKG.yml
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/onlp-platform-any.yml PLATFORM=x86-64-cel-questone-2a ARCH=amd64 TOOLCHAIN=x86_64-linux-gnu
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/Makefile b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/Makefile
new file mode 100644
index 000000000000..e7437cb23a2e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/Makefile
@@ -0,0 +1,2 @@
+FILTER=src
+include $(ONL)/make/subdirs.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/lib/Makefile b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/lib/Makefile
new file mode 100644
index 000000000000..41c08c2123e6
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/lib/Makefile
@@ -0,0 +1,2 @@
+PLATFORM := x86-64-cel-questone-2a
+include $(ONL)/packages/base/any/onlp/builds/platform/libonlp-platform.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/onlpdump/Makefile b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/onlpdump/Makefile
new file mode 100644
index 000000000000..321a978ea669
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/onlpdump/Makefile
@@ -0,0 +1,2 @@
+PLATFORM := x86-64-cel-questone-2a
+include $(ONL)/packages/base/any/onlp/builds/platform/onlps.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/.module b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/.module
new file mode 100644
index 000000000000..62b0ad15f282
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/.module
@@ -0,0 +1 @@
+name: x86_64_cel_questone_2a
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/Makefile b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/Makefile
new file mode 100644
index 000000000000..ac2ebd28eb23
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/Makefile
@@ -0,0 +1,9 @@
+###############################################################################
+#
+#
+#
+###############################################################################
+include $(ONL)/make/config.mk
+MODULE := x86_64_cel_questone_2a
+AUTOMODULE := x86_64_cel_questone_2a
+include $(BUILDER)/definemodule.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/make.mk b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/make.mk
new file mode 100644
index 000000000000..868a326072db
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/make.mk
@@ -0,0 +1,9 @@
+###############################################################################
+#
+# x86_64_cel_questone_2a Autogeneration
+#
+###############################################################################
+x86_64_cel_questone_2a_AUTO_DEFS := module/auto/x86_64_cel_questone_2a.yml
+x86_64_cel_questone_2a_AUTO_DIRS := module/inc/x86_64_cel_questone_2a module/src
+include $(BUILDER)/auto.mk
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/x86_64_cel_questone_2a.yml b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/x86_64_cel_questone_2a.yml
new file mode 100644
index 000000000000..6611e28014b7
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/auto/x86_64_cel_questone_2a.yml
@@ -0,0 +1,47 @@
+###############################################################################
+#
+# x86_64_cel_questone_2a Autogeneration Definitions.
+#
+###############################################################################
+
+cdefs: &cdefs
+- X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING:
+    doc: "Include or exclude logging."
+    default: 1
+- X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT:
+    doc: "Default enabled log options."
+    default: AIM_LOG_OPTIONS_DEFAULT
+- X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT:
+    doc: "Default enabled log bits."
+    default: AIM_LOG_BITS_DEFAULT
+- X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT:
+    doc: "Default enabled custom log bits."
+    default: 0
+- X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB:
+    doc: "Default all porting macros to use the C standard libraries."
+    default: 1
+- X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS:
+    doc: "Include standard library headers for stdlib porting macros."
+    default: X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB
+- X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI:
+    doc: "Include generic uCli support."
+    default: 0
+
+
+definitions:
+  cdefs:
+    X86_64_CEL_QUESTONE_2A_CONFIG_HEADER:
+      defs: *cdefs
+      basename: x86_64_cel_questone_2a_config
+
+  portingmacro:
+    X86_64_CEL_QUESTONE_2A:
+      macros:
+        - malloc
+        - free
+        - memset
+        - memcpy
+        - strncpy
+        - vsnprintf
+        - snprintf
+        - strlen
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a.x b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a.x
new file mode 100644
index 000000000000..c2259390e67b
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a.x
@@ -0,0 +1,14 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+/* <--auto.start.xmacro(ALL).define> */
+/* <auto.end.xmacro(ALL).define> */
+
+/* <--auto.start.xenum(ALL).define> */
+/* <auto.end.xenum(ALL).define> */
+
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h
new file mode 100644
index 000000000000..24bdf27ae98c
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h
@@ -0,0 +1,127 @@
+/**************************************************************************//**
+ *
+ * @file
+ * @brief x86_64_cel_questone_2a Configuration Header
+ *
+ * @addtogroup x86_64_cel_questone_2a-config
+ * @{
+ *
+ *****************************************************************************/
+#ifndef __X86_64_CEL_QUESTONE_2A_CONFIG_H__
+#define __X86_64_CEL_QUESTONE_2A_CONFIG_H__
+
+#ifdef GLOBAL_INCLUDE_CUSTOM_CONFIG
+#include <global_custom_config.h>
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_INCLUDE_CUSTOM_CONFIG
+#include <x86_64_cel_questone_2a_custom_config.h>
+#endif
+
+/* <auto.start.cdefs(X86_64_CEL_QUESTONE_2A_CONFIG_HEADER).header> */
+#include <AIM/aim.h>
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING
+ *
+ * Include or exclude logging. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING
+#define X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING 1
+#endif
+
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT
+ *
+ * Default enabled log options. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT
+#define X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT AIM_LOG_OPTIONS_DEFAULT
+#endif
+
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT
+ *
+ * Default enabled log bits. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT
+#define X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT AIM_LOG_BITS_DEFAULT
+#endif
+
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+ *
+ * Default enabled custom log bits. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+#define X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT 0
+#endif
+
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB
+ *
+ * Default all porting macros to use the C standard libraries. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB
+#define X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB 1
+#endif
+
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS
+ *
+ * Include standard library headers for stdlib porting macros. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS
+#define X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB
+#endif
+
+/**
+ * X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI
+ *
+ * Include generic uCli support. */
+
+
+#ifndef X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI
+#define X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI 0
+#endif
+
+
+
+/**
+ * All compile time options can be queried or displayed
+ */
+
+/** Configuration settings structure. */
+typedef struct x86_64_cel_questone_2a_config_settings_s {
+    /** name */
+    const char* name;
+    /** value */
+    const char* value;
+} x86_64_cel_questone_2a_config_settings_t;
+
+/** Configuration settings table. */
+/** x86_64_cel_questone_2a_config_settings table. */
+extern x86_64_cel_questone_2a_config_settings_t x86_64_cel_questone_2a_config_settings[];
+
+/**
+ * @brief Lookup a configuration setting.
+ * @param setting The name of the configuration option to lookup.
+ */
+const char* x86_64_cel_questone_2a_config_lookup(const char* setting);
+
+/**
+ * @brief Show the compile-time configuration.
+ * @param pvs The output stream.
+ */
+int x86_64_cel_questone_2a_config_show(struct aim_pvs_s* pvs);
+
+/* <auto.end.cdefs(X86_64_CEL_QUESTONE_2A_CONFIG_HEADER).header> */
+
+#include "x86_64_cel_questone_2a_porting.h"
+
+#endif /* __X86_64_CEL_QUESTONE_2A_CONFIG_H__ */
+/* @} */
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_dox.h b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_dox.h
new file mode 100644
index 000000000000..20dfe74ddb70
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_dox.h
@@ -0,0 +1,26 @@
+/**************************************************************************//**
+ *
+ * x86_64_cel_questone_2a Doxygen Header
+ *
+ *****************************************************************************/
+#ifndef __X86_64_CEL_QUESTONE_2A_DOX_H__
+#define __X86_64_CEL_QUESTONE_2A_DOX_H__
+
+/**
+ * @defgroup x86_64_cel_questone_2a x86_64_cel_questone_2a - x86_64_cel_questone_2a Description
+ *
+
+The documentation overview for this module should go here.
+
+ *
+ * @{
+ *
+ * @defgroup x86_64_cel_questone_2a-x86_64_cel_questone_2a Public Interface
+ * @defgroup x86_64_cel_questone_2a-config Compile Time Configuration
+ * @defgroup x86_64_cel_questone_2a-porting Porting Macros
+ *
+ * @}
+ *
+ */
+
+#endif /* __X86_64_CEL_QUESTONE_2A_DOX_H__ */
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_porting.h b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_porting.h
new file mode 100644
index 000000000000..075d1d52932c
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/inc/x86_64_cel_questone_2a/x86_64_cel_questone_2a_porting.h
@@ -0,0 +1,107 @@
+/**************************************************************************//**
+ *
+ * @file
+ * @brief x86_64_cel_questone_2a Porting Macros.
+ *
+ * @addtogroup x86_64_cel_questone_2a-porting
+ * @{
+ *
+ *****************************************************************************/
+#ifndef __X86_64_CEL_QUESTONE_2A_PORTING_H__
+#define __X86_64_CEL_QUESTONE_2A_PORTING_H__
+
+
+/* <auto.start.portingmacro(ALL).define> */
+#if X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS == 1
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <memory.h>
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_MALLOC
+    #if defined(GLOBAL_MALLOC)
+        #define X86_64_CEL_QUESTONE_2A_MALLOC GLOBAL_MALLOC
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_MALLOC malloc
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_MALLOC is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_FREE
+    #if defined(GLOBAL_FREE)
+        #define X86_64_CEL_QUESTONE_2A_FREE GLOBAL_FREE
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_FREE free
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_FREE is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_MEMSET
+    #if defined(GLOBAL_MEMSET)
+        #define X86_64_CEL_QUESTONE_2A_MEMSET GLOBAL_MEMSET
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_MEMSET memset
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_MEMSET is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_MEMCPY
+    #if defined(GLOBAL_MEMCPY)
+        #define X86_64_CEL_QUESTONE_2A_MEMCPY GLOBAL_MEMCPY
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_MEMCPY memcpy
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_MEMCPY is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_STRNCPY
+    #if defined(GLOBAL_STRNCPY)
+        #define X86_64_CEL_QUESTONE_2A_STRNCPY GLOBAL_STRNCPY
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_STRNCPY strncpy
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_STRNCPY is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_VSNPRINTF
+    #if defined(GLOBAL_VSNPRINTF)
+        #define X86_64_CEL_QUESTONE_2A_VSNPRINTF GLOBAL_VSNPRINTF
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_VSNPRINTF vsnprintf
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_VSNPRINTF is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_SNPRINTF
+    #if defined(GLOBAL_SNPRINTF)
+        #define X86_64_CEL_QUESTONE_2A_SNPRINTF GLOBAL_SNPRINTF
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_SNPRINTF snprintf
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_SNPRINTF is required but cannot be defined.
+    #endif
+#endif
+
+#ifndef X86_64_CEL_QUESTONE_2A_STRLEN
+    #if defined(GLOBAL_STRLEN)
+        #define X86_64_CEL_QUESTONE_2A_STRLEN GLOBAL_STRLEN
+    #elif X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB == 1
+        #define X86_64_CEL_QUESTONE_2A_STRLEN strlen
+    #else
+        #error The macro X86_64_CEL_QUESTONE_2A_STRLEN is required but cannot be defined.
+    #endif
+#endif
+
+/* <auto.end.portingmacro(ALL).define> */
+
+
+#endif /* __X86_64_CEL_QUESTONE_2A_PORTING_H__ */
+/* @} */
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/make.mk b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/make.mk
new file mode 100644
index 000000000000..fe04cdccc56f
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/make.mk
@@ -0,0 +1,10 @@
+###############################################################################
+#
+# 
+#
+###############################################################################
+THIS_DIR := $(dir $(lastword $(MAKEFILE_LIST)))
+x86_64_cel_questone_2a_INCLUDES := -I $(THIS_DIR)inc
+x86_64_cel_questone_2a_INTERNAL_INCLUDES := -I $(THIS_DIR)src
+x86_64_cel_questone_2a_DEPENDMODULE_ENTRIES := init:x86_64_cel_questone_2a ucli:x86_64_cel_questone_2a
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/Makefile b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/Makefile
new file mode 100644
index 000000000000..552378c91b92
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/Makefile
@@ -0,0 +1,9 @@
+###############################################################################
+#
+# Local source generation targets.
+#
+###############################################################################
+
+ucli:
+	@../../../../tools/uclihandlers.py x86_64_cel_questone_2a_ucli.c
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/fani.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/fani.c
new file mode 100644
index 000000000000..c622ec7c7205
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/fani.c
@@ -0,0 +1,88 @@
+#include <onlp/platformi/fani.h>
+#include "platform.h"
+
+onlp_fan_info_t f_info[FAN_COUNT + 1] = {
+    {},
+    {
+        {ONLP_FAN_ID_CREATE(1), "Chassis Fan 1", 0},
+        0,
+        ONLP_FAN_CAPS_B2F | ONLP_FAN_CAPS_F2B | ONLP_FAN_CAPS_GET_RPM | ONLP_FAN_CAPS_GET_PERCENTAGE,
+    },
+    {
+        {ONLP_FAN_ID_CREATE(2), "Chassis Fan 2", 0},
+        0,
+        ONLP_FAN_CAPS_B2F | ONLP_FAN_CAPS_F2B | ONLP_FAN_CAPS_GET_RPM | ONLP_FAN_CAPS_GET_PERCENTAGE,
+    },
+    {
+        {ONLP_FAN_ID_CREATE(3), "Chassis Fan 3", 0},
+        0,
+        ONLP_FAN_CAPS_B2F | ONLP_FAN_CAPS_F2B | ONLP_FAN_CAPS_GET_RPM | ONLP_FAN_CAPS_GET_PERCENTAGE,
+    },
+    {
+        {ONLP_FAN_ID_CREATE(4), "Chassis Fan 4", 0},
+        0,
+        ONLP_FAN_CAPS_B2F | ONLP_FAN_CAPS_F2B | ONLP_FAN_CAPS_GET_RPM | ONLP_FAN_CAPS_GET_PERCENTAGE,
+    },
+    {
+        {ONLP_FAN_ID_CREATE(5), "PSU Fan 1", ONLP_PSU_ID_CREATE(1)},
+        0,
+        ONLP_FAN_CAPS_B2F | ONLP_FAN_CAPS_F2B | ONLP_FAN_CAPS_GET_RPM | ONLP_FAN_CAPS_GET_PERCENTAGE,
+    },
+    {
+        {ONLP_FAN_ID_CREATE(6), "PSU Fan 2", ONLP_PSU_ID_CREATE(2)},
+        0,
+        ONLP_FAN_CAPS_B2F | ONLP_FAN_CAPS_F2B | ONLP_FAN_CAPS_GET_RPM | ONLP_FAN_CAPS_GET_PERCENTAGE,
+    },
+};
+
+int onlp_fani_init(void)
+{
+    return ONLP_STATUS_OK;
+}
+
+int onlp_fani_info_get(onlp_oid_t id, onlp_fan_info_t *info_p)
+{
+    int fan_id;
+
+    fan_id = ONLP_OID_ID_GET(id);
+
+    *info_p = f_info[fan_id];
+
+    uint8_t spd_result;
+    int isfanb2f = 0;
+
+    if(fan_id <= FAN_COUNT - PSU_FAN_COUNT){
+        get_fan_info(fan_id, info_p->model, info_p->serial,&isfanb2f);
+    }else{
+        int psu_id = 0;
+        if(fan_id == FAN_COUNT - 1){
+            psu_id = 1;
+        }else if(fan_id == FAN_COUNT){
+            psu_id = 2;
+        }
+        get_psu_model_sn(psu_id, info_p->model, info_p->serial);
+        isfanb2f = -1;
+    }
+    
+
+    spd_result = get_fan_speed(fan_id,&(info_p->percentage), &(info_p->rpm));
+    if(spd_result){
+        return ONLP_FAN_STATUS_FAILED;
+    }
+
+    info_p->status |= ONLP_FAN_STATUS_PRESENT;
+
+    switch (isfanb2f)
+    {
+    case ONLP_FAN_STATUS_F2B:
+        info_p->status |= ONLP_FAN_STATUS_F2B;
+        break;
+    case ONLP_FAN_STATUS_B2F:
+        info_p->status |= ONLP_FAN_STATUS_B2F;
+        break;
+    default:
+        break;
+    }
+
+    return ONLP_STATUS_OK;
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/ledi.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/ledi.c
new file mode 100644
index 000000000000..93fbe0e9e1c1
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/ledi.c
@@ -0,0 +1,169 @@
+#include <onlp/platformi/ledi.h>
+#include <sys/mman.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include "platform.h"
+
+enum onlp_led_id
+{
+    LED_RESERVED = 0,
+    LED_SYSTEM,
+    LED_ALARM,
+    LED_PSU1,
+    LED_PSU2,
+    LED_FAN1,
+    LED_FAN2,
+    LED_FAN3,
+    LED_FAN4
+};
+
+/*
+ * Get the information for the given LED OID.
+ */
+static onlp_led_info_t led_info[] =
+{
+    { },
+    {
+        { ONLP_LED_ID_CREATE(LED_SYSTEM), "System LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_YELLOW | ONLP_LED_CAPS_YELLOW_BLINKING | ONLP_LED_CAPS_GREEN | 
+        ONLP_LED_CAPS_GREEN_BLINKING | ONLP_LED_CAPS_AUTO,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_ALARM), "Alert LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_YELLOW | ONLP_LED_CAPS_YELLOW_BLINKING | ONLP_LED_CAPS_GREEN | 
+        ONLP_LED_CAPS_GREEN_BLINKING,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_PSU1), "PSU-1 LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_AUTO | ONLP_LED_CAPS_YELLOW | ONLP_LED_CAPS_GREEN,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_PSU2), "PSU-2 LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_AUTO | ONLP_LED_CAPS_YELLOW | ONLP_LED_CAPS_GREEN,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_FAN1), "Chassis FAN(1) LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_RED |  ONLP_LED_CAPS_GREEN | ONLP_LED_CAPS_AUTO,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_FAN2), "Chassis FAN(2) LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_RED |  ONLP_LED_CAPS_GREEN | ONLP_LED_CAPS_AUTO,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_FAN3), "Chassis FAN(3) LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_RED |  ONLP_LED_CAPS_GREEN | ONLP_LED_CAPS_AUTO,
+    },
+    {
+        { ONLP_LED_ID_CREATE(LED_FAN4), "Chassis FAN(4) LED", 0 },
+        ONLP_LED_STATUS_PRESENT,
+        ONLP_LED_CAPS_ON_OFF | ONLP_LED_CAPS_RED |  ONLP_LED_CAPS_GREEN | ONLP_LED_CAPS_AUTO,
+    }
+};
+
+int
+onlp_ledi_init(void)
+{
+    return ONLP_STATUS_OK;
+}
+
+int
+onlp_ledi_info_get(onlp_oid_t id, onlp_led_info_t* info_p)
+{
+    int led_id;
+    uint8_t led_color = 0;
+    uint8_t alert_status,present_status =0;
+    uint8_t blink_status = 0;
+    uint8_t result = 0;
+
+    led_id = ONLP_OID_ID_GET(id);
+    *info_p = led_info[led_id];
+ 
+    result = get_led_status(led_id);
+
+    if(result != 0xFF)
+        info_p->status |= ONLP_LED_STATUS_ON;
+
+    switch(led_id){
+        case LED_SYSTEM:
+        case LED_ALARM:
+
+            led_color = (result >> 4)&0x3;
+            if(led_color == 0){
+                if(led_id==LED_SYSTEM)
+                    info_p->mode |= ONLP_LED_MODE_AUTO;
+                if(led_id==LED_ALARM)
+                    info_p->mode |= ONLP_LED_MODE_OFF;
+            }
+            if(led_color == 1){
+                info_p->mode |= ONLP_LED_MODE_GREEN;
+            }
+            if(led_color == 2){
+                info_p->mode |= ONLP_LED_MODE_YELLOW;
+            }
+            if(led_color == 3){
+                info_p->mode |= ONLP_LED_MODE_OFF;
+                break;
+            }
+
+            blink_status = result & 0x3;
+            if(blink_status == 1 || blink_status == 2){
+                int current_mode = info_p->mode;
+                info_p->mode = current_mode+1;
+            }
+
+            break;
+        case LED_FAN1:
+        case LED_FAN2:
+        case LED_FAN3:
+        case LED_FAN4:
+            led_color = result & 0x3;
+
+            if(led_color == 0){
+                info_p->mode |= ONLP_LED_MODE_OFF;
+            }
+            if(led_color == 1){
+                info_p->mode |= ONLP_LED_MODE_GREEN;
+            }
+            if(led_color == 2){
+                info_p->mode |= ONLP_LED_MODE_RED;
+            }
+            break;
+        case LED_PSU1:
+            alert_status = (result >> 7) & 0x1;
+            present_status = (result >> 5) & 0x1;
+
+            if(present_status == 0){
+                if(alert_status == 1){
+                    info_p->mode |= ONLP_LED_MODE_GREEN;
+                }else{
+                    info_p->mode |= ONLP_LED_MODE_YELLOW;
+                }
+            }else{
+                info_p->mode |= ONLP_LED_MODE_YELLOW;
+            }
+            break;
+        case LED_PSU2:
+            alert_status = (result >> 6) & 0x1;
+            present_status = (result >> 4) & 0x1;
+
+            if(present_status == 0){
+                if(alert_status == 1){
+                    info_p->mode |= ONLP_LED_MODE_GREEN;
+                }else{
+                    info_p->mode |= ONLP_LED_MODE_YELLOW;
+                }
+            }else{
+                info_p->mode |= ONLP_LED_MODE_YELLOW;
+            }
+            break;
+    }
+    return ONLP_STATUS_OK;
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/make.mk b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/make.mk
new file mode 100644
index 000000000000..a34f7801e37e
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/make.mk
@@ -0,0 +1,9 @@
+###############################################################################
+#
+#
+#
+###############################################################################
+
+LIBRARY := x86_64_cel_questone_2a
+$(LIBRARY)_SUBDIR := $(dir $(lastword $(MAKEFILE_LIST)))
+include $(BUILDER)/lib.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.c
new file mode 100644
index 000000000000..fada4005f975
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.c
@@ -0,0 +1,1099 @@
+//////////////////////////////////////////////////////////////
+//   PLATFORM FUNCTION TO INTERACT WITH SYS_CPLD AND BMC    //
+//////////////////////////////////////////////////////////////
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <sys/io.h>
+
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#include "platform.h"
+
+char command[256];
+FILE *fp;
+
+static struct device_info fan_information[FAN_COUNT + 1] = {
+    {"unknown", "unknown",1}, //check
+    {}, //Fan 1
+    {}, //Fan 2
+    {}, //Fan 3
+    {}, //Fan 4
+    {}, //PSU Fan1
+    {}, //PSU Fan2
+};
+
+static struct device_info psu_information[PSU_COUNT + 1] = {
+    {"unknown", "unknown"}, //check
+    {}, //PSU 1
+    {}, //PSU 2
+};
+
+static const struct led_reg_mapper led_mapper[LED_COUNT + 1] = {
+    {},
+    {"LED_SYSTEM", LED_SYSTEM_H, LED_SYSTEM_REGISTER},
+    {"LED_ALARM", LED_ALARM_H, ALARM_REGISTER},
+    {"LED_PSU1", LED_PSU1_H, PSU_LED_REGISTER},
+    {"LED_PSU2", LED_PSU2_H, PSU_LED_REGISTER},
+    {"LED_FAN1",LED_FAN1_H,LED_FAN1_REGISTER},
+    {"LED_FAN2", LED_FAN2_H,LED_FAN2_REGISTER},
+    {"LED_FAN4", LED_FAN4_H,LED_FAN4_REGISTER},
+    {"LED_FAN5", LED_FAN5_H,LED_FAN5_REGISTER}
+};
+
+static const struct psu_reg_bit_mapper psu_mapper [PSU_COUNT + 1] = {
+    {},
+    {0xa160, 3, 7, 1},
+    {0xa160, 2, 6, 0},
+};
+
+void update_shm_mem(void)
+{
+    (void)fill_shared_memory(ONLP_SENSOR_CACHE_SHARED, ONLP_SENSOR_CACHE_SEM, ONLP_SENSOR_CACHE_FILE);
+    (void)fill_shared_memory(ONLP_FRU_CACHE_SHARED, ONLP_FRU_CACHE_SEM, ONLP_FRU_CACHE_FILE);
+    (void)fill_shared_memory(ONLP_SENSOR_LIST_CACHE_SHARED, ONLP_SENSOR_LIST_SEM, ONLP_SENSOR_LIST_FILE);
+}
+
+int is_cache_exist(){
+    const char *sdr_cache_path="/tmp/onlp-sensor-list-cache.txt";
+    const char *fru_cache_path="/tmp/onlp-fru-cache.txt";
+    const char *time_setting_path="/var/opt/interval_time.txt";
+    time_t current_time;
+    int interval_time = 30; //set default to 30 sec
+    double sdr_diff_time,fru_diff_time;
+    struct stat sdr_fst,fru_fst;
+    bzero(&sdr_fst,sizeof(sdr_fst));
+    bzero(&fru_fst,sizeof(fru_fst));
+
+    //Read setting
+    if(access(time_setting_path, F_OK) == -1){ //Setting not exist
+        return -1;
+    }else{
+        FILE *fp;
+        
+        fp = fopen(time_setting_path, "r"); // read setting
+        
+        if (fp == NULL)
+        {
+            perror("Error while opening the file.\n");
+            exit(EXIT_FAILURE);
+        }
+
+        fscanf(fp,"%d", &interval_time);
+
+        fclose(fp);
+    }
+
+    if ((access(sdr_cache_path, F_OK) == -1) && (access(fru_cache_path, F_OK) == -1)){ //Cache not exist
+        return -1;
+    }else{ //Cache exist
+        current_time = time(NULL);
+        if (stat(sdr_cache_path,&sdr_fst) != 0) { printf("stat() sdr_cache failed\n"); return -1; }
+        if (stat(fru_cache_path,&fru_fst) != 0) { printf("stat() fru_cache failed\n"); return -1; }
+
+        sdr_diff_time = difftime(current_time,sdr_fst.st_mtime);
+        fru_diff_time = difftime(current_time,fru_fst.st_mtime);
+
+        if((sdr_diff_time > interval_time)&&(fru_diff_time > interval_time)){
+            return -1;
+        }
+        return 1;
+    }
+}
+
+int is_shm_mem_ready(){
+
+    if(USE_SHM_METHOD){
+        const char *sdr_cache_path="/run/shm/onlp-sensor-list-cache-shared";
+        const char *fru_cache_path="/run/shm/onlp-fru-cache-shared";
+
+        if(access(fru_cache_path, F_OK) == -1 || access(sdr_cache_path, F_OK) == -1 ){ //Shared cache files not exist
+            return 0;
+        }
+
+    return 1;
+    }
+    
+    return 0;
+}
+
+int create_cache(){
+    (void)system("ipmitool fru > /tmp/onlp-fru-cache.tmp; sync; rm -f /tmp/onlp-fru-cache.txt; mv /tmp/onlp-fru-cache.tmp /tmp/onlp-fru-cache.txt");
+    (void)system("ipmitool sensor list > /tmp/onlp-sensor-list-cache.tmp; sync; rm -f /tmp/onlp-sensor-list-cache.txt; mv /tmp/onlp-sensor-list-cache.tmp /tmp/onlp-sensor-list-cache.txt");
+    if(USE_SHM_METHOD){
+        update_shm_mem();
+    }
+    return 1;
+}
+
+void array_trim(char *strIn, char *strOut)
+{
+    int i, j;
+
+    i = 0;
+    j = strlen(strIn) - 1;
+
+    while(strIn[i] == ' ') ++i;
+    while(strIn[j] == ' ') --j;
+
+    strncpy(strOut, strIn + i , j - i + 1);
+    strOut[j - i + 1] = '\0';
+}
+
+uint8_t read_register(uint16_t dev_reg)
+{
+    int status;
+    sprintf(command, "echo 0x%x >  %sgetreg", dev_reg, SYS_CPLD_PATH);
+    fp = popen(command, "r");
+    if (!fp)
+    {
+        printf("Failed : Can't specify CPLD register\n");
+        return -1;
+    }
+    pclose(fp);
+    fp = popen("cat " SYS_CPLD_PATH "getreg", "r");
+    if (!fp)
+    {
+        printf("Failed : Can't open sysfs\n");
+        return -1;
+    }
+    fscanf(fp, "%x", &status);
+    pclose(fp);
+
+    return status;
+}
+
+int exec_ipmitool_cmd(char *cmd, char *retd)
+{
+    int ret = 0;
+    int i = 0;
+    char c;
+    FILE *pFd = NULL;
+
+    pFd = popen(cmd, "r");
+    if (pFd != NULL)
+    {
+        c = fgetc(pFd);
+        while (c != EOF)
+        {
+            //printf ("%c", c);
+            retd[i] = c;
+            i++;
+            c = fgetc(pFd);
+        }
+        pclose(pFd);
+    }
+
+    return ret;
+}
+
+uint8_t get_led_status(int id)
+{
+    uint8_t ret = 0xFF;
+
+    if (id >= (LED_COUNT + 2) || id < 0)
+        return 0xFF;
+
+    if (id <= (LED_COUNT))
+    {
+        uint8_t result = 0;
+        uint16_t led_stat_reg;
+        led_stat_reg = led_mapper[id].dev_reg; 
+        result = read_register(led_stat_reg);     
+        ret = result;
+    }
+
+    return ret;
+}
+
+char *read_tmp_cache(char *cmd, char *cache_file_path)
+{
+    FILE* pFd = NULL;
+    char *str = NULL;
+    int round = 1;
+
+    for(round = 1;round <= 10;round++){
+        pFd = fopen(cache_file_path, "r");
+        if(pFd != NULL ){
+
+            struct stat st;
+
+            stat(cache_file_path, &st);
+
+            int size = st.st_size;
+            str = (char *)malloc(size + 1);
+            
+            memset (str, 0, size+1);
+
+            fread(str, size+1, 1, pFd);
+
+            fclose(pFd);
+            break;
+        }else{
+            usleep(5000); //Sleep for 5 Microsec for waiting the file operation complete
+        }
+    }
+
+    if(round >= 10 && str == NULL){
+        str = (char *)malloc(1);
+        memset (str, 0, 1);
+    }
+    
+    return str;
+}
+
+uint8_t get_psu_status(int id)
+{
+    uint8_t ret = 0xFF;
+    uint16_t psu_stat_reg;
+
+    if (id <= (PSU_COUNT))
+    {
+        uint8_t result = 0;
+        psu_stat_reg = psu_mapper[id].sta_reg;
+        result = read_register(psu_stat_reg);
+        ret = result;
+    }
+
+    return ret;
+}
+
+int get_psu_info(int id, int *mvin, int *mvout, int *mpin, int *mpout, int *miin, int *miout)
+{
+    char *tmp = (char *)NULL;
+    int len = 0;
+    int index  = 0;
+
+	int i = 0;
+	int ret = 0;
+    char strTmp[12][128] = {{0}, {0}};
+    char *token = NULL;
+    char *psu_sensor_name[12] = {
+        "PSUL_VIn", "PSUL_CIn", "PSUL_PIn", "PSUL_VOut",
+        "PSUL_COut", "PSUL_POut", "PSUR_VIn", "PSUR_CIn",
+        "PSUR_PIn", "PSUR_VOut","PSUR_COut","PSUR_POut"};
+
+    /*
+        String example:			  
+        root@localhost:~# ipmitool sensor list | grep PSU
+        PSUL_Status      | 0x0        | discrete   | 0x0180| na        | na        | na        | na        | na        | na        
+        PSUR_Status      | 0x0        | discrete   | 0x0180| na        | na        | na        | na        | na        | na        
+        PSUL_Fan         | na         | RPM        | na    | na        | na        | na        | na        | na        | na        
+        PSUR_Fan         | 15800.000  | RPM        | ok    | na        | na        | na        | na        | na        | na        
+        PSUL_VIn         | na         | Volts      | na    | na   0     | na        | na        | 239.800   | 264.000   | na        
+        PSUL_CIn         | na         | Amps       | na    | na   1    | na        | na        | na        | 14.080    | na        
+        PSUL_PIn         | na         | Watts      | na    | na   2    | na        | na        | na        | 1500.000  | na        
+        PSUL_Temp1       | na         | degrees C  | na    | na       | na        | na        | na        | na        | na        
+        PSUL_Temp2       | na         | degrees C  | na    | na        | na        | na        | na        | na        | na        
+        PSUL_VOut        | na         | Volts      | na    | na   3    | na        | na        | na        | 13.500    | 15.600    
+        PSUL_COut        | na         | Amps       | na    | na   4    | na        | na        | na        | 125.000   | na        
+        PSUL_POut        | na         | Watts      | na    | na   5    | na        | na        | na        | 1500.000  | na        
+        PSUR_VIn         | 228.800    | Volts      | ok    | na   6    | na        | na        | 239.800   | 264.000   | na        
+        PSUR_CIn         | 0.480      | Amps       | ok    | na   7    | na        | na        | na        | 14.080    | na        
+        PSUR_PIn         | 114.000    | Watts      | ok    | na   8     | na        | na        | na        | 1500.000  | na        
+        PSUR_Temp1       | 26.000     | degrees C  | ok    | na        | na        | na        | na        | na        | na        
+        PSUR_Temp2       | 43.000     | degrees C  | ok    | na        | na        | na        | na        | na        | na        
+        PSUR_VOut        | 12.000     | Volts      | ok    | na   9     | na        | na        | na        | 13.500    | 15.600    
+        PSUR_COut        | 7.500      | Amps       | ok    | na   10     | na        | na        | na        | 125.000   | na        
+        PSUR_POut        | 90.000     | Watts      | ok    | na   11     | na        | na        | na        | 1500.000  | na        
+        root@localhost:~# 
+    */
+    if((NULL == mvin) || (NULL == mvout) ||(NULL == mpin) || (NULL == mpout) || (NULL == miin) || (NULL == miout))
+	{
+		printf("%s null pointer!\n", __FUNCTION__);
+		return -1;
+	}
+
+    if(is_shm_mem_ready()){
+        ret = open_file(ONLP_SENSOR_LIST_CACHE_SHARED,ONLP_SENSOR_LIST_SEM, &tmp, &len);
+        if(ret < 0 || !tmp){
+            printf("Failed - Failed to obtain system information\n");
+            (void)free(tmp);
+            tmp = (char *)NULL;
+            return ret;
+        }
+    }else{
+        // use unsafe method to read the cache file.
+        sprintf(command, "cat %s",ONLP_SENSOR_LIST_FILE);
+        tmp = read_tmp_cache(command,ONLP_SENSOR_LIST_FILE);
+    }
+
+    char *content, *temp_pointer;
+    int flag = 0;
+    content = strtok_r(tmp, "\n", &temp_pointer);
+
+    int search_from = 0;
+    int search_to = 0;
+
+    if(id == 1){
+        search_from = 0;
+        search_to = 5;
+    }else{
+        search_from = 6;
+        search_to = 11;
+    }
+    
+    while(content != NULL && search_from <= search_to){
+        if (strstr(content, psu_sensor_name[search_from]))
+        {
+            flag = 1;
+            index++;
+        }
+
+        if(flag == 1){
+            i = 0;
+            token = strtok(content, "|");
+            while( token != NULL ) 
+            {
+                if(i == 1){
+                    array_trim(token, &strTmp[search_from][i]);
+                    search_from++;
+                }
+                i++;
+                if(i > 2) break;
+                token = strtok(NULL, "|");
+            }
+        }
+
+
+        flag = 0;
+        content = strtok_r(NULL, "\n", &temp_pointer);
+    }
+
+    if(content){
+        content = (char *)NULL;
+    }
+    if(temp_pointer){
+        temp_pointer = (char *)NULL;
+    }
+    if(tmp){
+    	(void)free(tmp);
+	    tmp = (char *)NULL;
+    }
+
+    if (id == 1)
+    {
+        if (0 == strcmp(&strTmp[0][1], "na"))
+            *mvin = 0;
+        else
+            *mvin = atof(&strTmp[0][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[3][1], "na"))
+            *mvout = 0;
+        else
+            *mvout = atof(&strTmp[3][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[2][1], "na"))
+            *mpin = 0;
+        else
+            *mpin = atof(&strTmp[2][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[5][1], "na"))
+            *mpout = 0;
+        else
+            *mpout = atof(&strTmp[5][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[1][1], "na"))
+            *miin = 0;
+        else
+            *miin = atof(&strTmp[1][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[4][1], "na"))
+            *miout = 0;
+        else
+            *miout = atof(&strTmp[4][1]) * 1000.0;
+    }
+    else
+    {
+        if (0 == strcmp(&strTmp[6][1], "na"))
+            *mvin = 0;
+        else
+            *mvin = atof(&strTmp[6][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[9][1], "na"))
+            *mvout = 0;
+        else
+            *mvout = atof(&strTmp[9][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[8][1], "na"))
+            *mpin = 0;
+        else
+            *mpin = atof(&strTmp[8][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[11][1], "na"))
+            *mpout = 0;
+        else
+            *mpout = atof(&strTmp[11][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[7][1], "na"))
+            *miin = 0;
+        else
+            *miin = atof(&strTmp[7][1]) * 1000.0;
+
+        if (0 == strcmp(&strTmp[10][1], "na"))
+            *miout = 0;
+        else
+            *miout = atof(&strTmp[10][1]) * 1000.0;
+    }
+
+    return ret;
+}
+
+int get_psu_model_sn(int id, char *model, char *serial_number)
+{
+    int index;
+    char *token;
+    char *tmp = (char *)NULL;
+    int len = 0;
+    int ret = -1;
+    int search_psu_id = 1;
+
+    if (0 == strcasecmp(psu_information[0].model, "unknown")) {
+        
+        index = 0;
+        if(is_shm_mem_ready()){
+            ret = open_file(ONLP_FRU_CACHE_SHARED,ONLP_FRU_CACHE_SEM, &tmp, &len);
+            if(ret < 0 || !tmp){
+                printf("Failed - Failed to obtain system information\n");
+                (void)free(tmp);
+                tmp = (char *)NULL;
+                return ret;
+            }
+        }else{
+            // use unsafe method to read the cache file.
+            sprintf(command, "cat %s",ONLP_FRU_CACHE_FILE);
+            tmp = read_tmp_cache(command,ONLP_FRU_CACHE_FILE);
+        }
+        
+        char *content, *temp_pointer;
+        int flag = 0;
+        /*
+        String example:			  
+        root@localhost:~# ipmitool fru (Pull out PSUL)
+
+        FRU Device Description : FRU_PSUL (ID 4)
+         Device not present (Unknown (0x81))
+
+        FRU Device Description : FRU_PSUR (ID 4)
+        Product Manufacturer  : DELTA
+        Product Name          : DPS-550AB-21 B
+        Product Part Number   : XXXXXXXXXXXXXXXXXXXX
+        Product Version       : S0F
+        Product Serial        : IRJD1733001328
+
+        */
+        content = strtok_r(tmp, "\n", &temp_pointer);
+
+        while(content != NULL){
+            if (strstr(content, "FRU Device Description : FRU_PSU")) {
+                flag = 1;
+                index++;
+            }
+            if(flag == 1){
+                if (strstr(content, "Device not present")) {
+                    index++;
+                    flag=0;
+                }
+                else if (strstr(content, "Product Part Number")) {
+                    token = strtok(content, ":");
+                    token = strtok(NULL, ":");
+                    char* trim_token = trim(token);
+                    sprintf(psu_information[index].model,"%s",trim_token);
+                }
+                else if (strstr(content, "Product Serial")) {
+                    token = strtok(content, ":");
+                    token = strtok(NULL, ":");
+                    char* trim_token = trim(token);
+                    sprintf(psu_information[index].serial_number,"%s",trim_token);
+                    flag = 0;
+                    search_psu_id++;
+                }
+            }
+            if(search_psu_id > PSU_COUNT){
+                content = NULL;
+            }else{
+                content = strtok_r(NULL, "\n", &temp_pointer);
+            }
+        }
+
+        sprintf(psu_information[0].model,"pass"); //Mark as complete
+
+        if(temp_pointer){
+            temp_pointer = (char *)NULL;
+        }
+        if(tmp){
+    	    (void)free(tmp);
+	        tmp = (char *)NULL;
+        }
+    }
+
+    strcpy(model, psu_information[id].model);
+    strcpy(serial_number, psu_information[id].serial_number);
+
+    return 1;
+}
+
+int get_fan_info(int id, char *model, char *serial, int *isfanb2f)
+{
+    int index;
+    char *token;
+    char *tmp = (char *)NULL;
+    int len = 0;
+    int ret = -1;
+
+    if (0 == strcasecmp(fan_information[0].model, "unknown")) {
+        index = 0;
+        if(is_shm_mem_ready()){
+            ret = open_file(ONLP_FRU_CACHE_SHARED,ONLP_FRU_CACHE_SEM, &tmp, &len);
+            if(ret < 0 || !tmp){
+                printf("Failed - Failed to obtain system information\n");
+                (void)free(tmp);
+                tmp = (char *)NULL;
+                return ret;
+            }
+        }else{
+            // use unsafe method to read the cache file.
+            sprintf(command, "cat %s",ONLP_FRU_CACHE_FILE);
+            tmp = read_tmp_cache(command,ONLP_FRU_CACHE_FILE);
+        }
+        /*
+        String example:			  
+        root@localhost:~# ipmitool fru (Pull out FAN1)
+
+        FRU Device Description : FRU_FAN1 (ID 5)
+         Device not present (Unknown (0x81))
+
+        FRU Device Description : FRU_FAN2 (ID 6)
+        Board Mfg Date        : Wed Jun  5 03:19:00 2019
+        Board Mfg             : Celestica
+        Board Serial          : F302-R1156F002801-19210027
+        Board Part Number     : R1156-F0028-01
+        Board Extra           : Questone2A-Fan
+        Board Extra           : R02
+        Board Extra           : B2F
+        Board Extra           : F302D
+
+
+        */
+        char *content, *temp_pointer;
+        int flag = 0;
+        content = strtok_r(tmp, "\n", &temp_pointer);
+
+        while(content != NULL){
+            if (strstr(content, "FRU_FAN") && !strstr(content,"FRU_FANBRD")) {
+                flag = 1;
+                index++;
+            }
+            if(flag == 1){
+                if (strstr(content, "Device not present")) {
+                    index++;
+                    flag=0;
+                }
+                else if (strstr(content, "Board Serial")) {
+                    token = strtok(content, ":");
+                    token = strtok(NULL, ":");
+                    char* trim_token = trim(token);
+                    sprintf(fan_information[index].serial_number,"%s",trim_token);
+                }
+                else if (strstr(content, "Board Part Number")) {
+                    token = strtok(content, ":");
+                    token = strtok(NULL, ":");
+                    char* trim_token = trim(token);
+                    sprintf(fan_information[index].model,"%s",trim_token);
+                    
+                }else if (strstr(content, "Board Extra")) 
+                {
+                    token = strtok(content, ":");
+                    token = strtok(NULL, ":");
+                    char* trim_token = trim(token);
+                    //Check until find B2F or F2B
+                    if(strcmp(trim_token, "B2F") == 0){
+                        fan_information[index].airflow = 4;
+                        flag = 0;
+                    }else if(strcmp(trim_token ,"F2B") == 0){
+                        fan_information[index].airflow = 8;
+                        flag = 0;
+                    }
+
+                }
+                
+            }
+            if(index > FAN_COUNT){
+                content = NULL;
+            }else{
+                content = strtok_r(NULL, "\n", &temp_pointer);
+            }
+        }
+
+        sprintf(fan_information[0].model,"pass"); //Mark as complete
+
+        if(temp_pointer){
+            temp_pointer = (char *)NULL;
+        }
+        if(tmp){
+    	    (void)free(tmp);
+	        tmp = (char *)NULL;
+        }
+    }
+    strcpy(model, fan_information[id].model);
+    strcpy(serial, fan_information[id].serial_number);
+    *isfanb2f = fan_information[id].airflow;
+    
+    return 1;
+}
+
+int get_sensor_info(int id, int *temp, int *warn, int *error, int *shutdown)
+{
+    char *tmp = (char *)NULL;
+    int len = 0;
+    int index  = 0;
+
+	int i = 0;
+	int ret = 0;
+    char strTmp[10][128] = {{0}, {0}};
+    char *token = NULL;
+    char *Thermal_sensor_name[13] = {
+        "Base_Temp_U5", "Base_Temp_U7", "CPU_Temp", "Switch_Temp_U31",
+        "Switch_Temp_U30", "Switch_Temp_U28", "Switch_Temp_U29","Switch_U21_Temp","Switch_U33_Temp", 
+        "PSUL_Temp1","PSUL_Temp2", "PSUR_Temp1", "PSUR_Temp2"};
+
+	if((NULL == temp) || (NULL == warn) || (NULL == error) || (NULL == shutdown))
+	{
+		printf("%s null pointer!\n", __FUNCTION__);
+		return -1;
+	}
+
+    /*
+        String example:			  
+        ipmitool sensor list
+        TEMP_CPU     | 1.000      | degrees C  | ok  | 5.000  | 9.000  | 16.000  | 65.000  | 73.000  | 75.606
+        TEMP_FAN_U52 | 32.000	  | degrees C  | ok  | na  |  na  | na  | na  | 70.000  | 75.000
+        PSUR_Temp1   | na         | degrees C  | na  | na  | na   | na   | na  | na  | na
+    */
+    if(is_shm_mem_ready()){
+        ret = open_file(ONLP_SENSOR_LIST_CACHE_SHARED,ONLP_SENSOR_LIST_SEM, &tmp, &len);
+        if(ret < 0 || !tmp){
+            printf("Failed - Failed to obtain system information\n");
+            (void)free(tmp);
+            tmp = (char *)NULL;
+            return ret;
+        }
+    }else{
+        // use unsafe method to read the cache file.
+        sprintf(command, "cat %s",ONLP_SENSOR_LIST_FILE);
+        tmp = read_tmp_cache(command,ONLP_SENSOR_LIST_FILE);
+    }
+    
+    char *content, *temp_pointer;
+    int flag = 0;
+    content = strtok_r(tmp, "\n", &temp_pointer);
+    while(content != NULL){
+        if (strstr(content, Thermal_sensor_name[id - 1])) {
+            flag = 1;
+            index++;
+        }
+        if(flag == 1){
+
+            i = 0;
+            token = strtok(content, "|");
+            while( token != NULL ) 
+            {
+                array_trim(token, &strTmp[i][0]);
+                i++;
+                if(i > 10) break;
+                token = strtok(NULL, "|");
+            }
+            
+            flag = 3;
+        }
+        
+        if(flag == 3){
+            content = NULL;
+        }else{
+            content = strtok_r(NULL, "\n", &temp_pointer);
+        }
+    }
+
+    if (0 == strcmp(&strTmp[1][0], "na"))
+        *temp = 0;
+    else
+        *temp = atof(&strTmp[1][0]) * 1000.0;
+
+    if (0 == strcmp(&strTmp[7][0], "na"))
+        *warn = 0;
+    else
+        *warn = atof(&strTmp[7][0]) * 1000.0;
+
+    if (0 == strcmp(&strTmp[8][0], "na"))
+        *error = 0;
+    else
+        *error = atof(&strTmp[8][0]) * 1000.0;
+
+    if (0 == strcmp(&strTmp[9][0], "na"))
+        *shutdown = 0;
+    else
+        *shutdown = atof(&strTmp[9][0]) * 1000.0;
+
+    if(content){
+        content = (char *)NULL;
+    }
+    if(temp_pointer){
+        temp_pointer = (char *)NULL;
+    }
+    if(tmp){
+    	(void)free(tmp);
+	    tmp = (char *)NULL;
+    }
+
+    return 0;
+}
+
+int get_fan_speed(int id,int *per, int *rpm)
+{
+    
+    int max_rpm_speed = 29700;// = 100% speed
+    char *tmp = (char *)NULL;
+    int len = 0;
+    int index  = 0;
+
+	int i = 0;
+	int ret = 0;
+    char strTmp[2][128] = {{0}, {0}};
+    char *token = NULL;
+    char *Fan_sensor_name[6] = {
+        "Fan1_Rear", "Fan2_Rear", "Fan3_Rear", "Fan4_Rear",
+        "PSUL_Fan","PSUR_Fan"};
+
+	if((NULL == per) || (NULL == rpm))
+	{
+		printf("%s null pointer!\n", __FUNCTION__);
+		return -1;
+	}
+
+    /*
+        String example:			  
+        ipmitool sensor list (Plug out FAN1 and PSU 1)
+        Fan1_Rear        | na         | RPM        | na    | na        | 1050.000  | na        | na        | na        | na        
+        Fan2_Rear        | 28650.000  | RPM        | ok    | na        | 1050.000  | na        | na        | na        | na        
+        Fan3_Rear        | 29250.000  | RPM        | ok    | na        | 1050.000  | na        | na        | na        | na        
+        Fan4_Rear        | 28650.000  | RPM        | ok    | na        | 1050.000  | na        | na        | na        | na        
+        Fan5_Rear        | 29400.000  | RPM        | ok    | na        | 1050.000  | na        | na        | na        | na        
+        Fan6_Rear        | 29100.000  | RPM        | ok    | na        | 1050.000  | na        | na        | na        | na        
+        Fan7_Rear        | 29100.000  | RPM        | ok    | na        | 1050.000  | na        | na        | na        | na   
+        PSUL_Fan         | na         | RPM        | na    | na        | na        | na        | na        | na        | na        
+        PSUR_Fan         | 15800.000  | RPM        | ok    | na        | na        | na        | na        | na        | na      
+    */
+    if(is_shm_mem_ready()){
+        ret = open_file(ONLP_SENSOR_LIST_CACHE_SHARED,ONLP_SENSOR_LIST_SEM, &tmp, &len);
+        if(ret < 0 || !tmp){
+            printf("Failed - Failed to obtain system information\n");
+            (void)free(tmp);
+            tmp = (char *)NULL;
+            return ret;
+        }
+    }else{
+        // use unsafe method to read the cache file.
+        sprintf(command, "cat %s",ONLP_SENSOR_LIST_FILE);
+        tmp = read_tmp_cache(command,ONLP_SENSOR_LIST_FILE);
+    }
+    char *content, *temp_pointer;
+    int flag = 0;
+    content = strtok_r(tmp, "\n", &temp_pointer);
+    while(content != NULL){;
+        if (strstr(content, Fan_sensor_name[id - 1])) {
+            flag = 1;
+            index++;
+        }
+        if(flag == 1){
+            i = 0;
+            token = strtok(content, "|");
+            while( token != NULL ) 
+            {
+                array_trim(token, &strTmp[i][0]);
+                i++;
+                if(i > 2) break;
+                token = strtok(NULL, "|");
+            }
+            
+            flag = 3;
+        }
+        
+        if(flag == 3){
+            content = NULL;
+        }else{
+            content = strtok_r(NULL, "\n", &temp_pointer);
+        }
+    }
+
+    if (0 == strcmp(&strTmp[1][0], "na")){
+        *rpm = 0;
+        ret = -1;
+    }else{
+        *rpm = atof(&strTmp[1][0]);
+    }
+
+    if (0 == strcmp(&strTmp[1][0], "na"))
+        *per = 0;
+    else
+        *per = (atof(&strTmp[1][0]) * 100 )/ max_rpm_speed;
+
+    if(content){
+        content = (char *)NULL;
+    }
+    if(temp_pointer){
+        temp_pointer = (char *)NULL;
+    }
+    if(tmp){
+    	(void)free(tmp);
+	    tmp = (char *)NULL;
+    }
+
+    return ret;
+}
+
+int read_device_node_binary(char *filename, char *buffer, int buf_size, int data_len)
+{
+    int fd;
+    int len;
+
+    if ((buffer == NULL) || (buf_size < 0))
+    {
+        return -1;
+    }
+
+    if ((fd = open(filename, O_RDONLY)) == -1)
+    {
+        return -1;
+    }
+
+    if ((len = read(fd, buffer, buf_size)) < 0)
+    {
+        close(fd);
+        return -1;
+    }
+
+    if ((close(fd) == -1))
+    {
+        return -1;
+    }
+
+    if ((len > buf_size) || (data_len != 0 && len != data_len))
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+int read_device_node_string(char *filename, char *buffer, int buf_size, int data_len)
+{
+    int ret;
+
+    if (data_len >= buf_size)
+    {
+        return -1;
+    }
+
+    ret = read_device_node_binary(filename, buffer, buf_size - 1, data_len);
+    if (ret == 0)
+    {
+        buffer[buf_size - 1] = '\0';
+    }
+
+    return ret;
+}
+
+char* trim (char *s)
+{
+    int i;
+
+    while (isspace (*s)) s++;   // skip left side white spaces
+    for (i = strlen (s) - 1; (isspace (s[i])); i--) ;   // skip right side white spaces
+    s[i + 1] = '\0';
+    
+    return s;
+}
+
+int fill_shared_memory(const char *shm_path, const char *sem_path, const char *cache_path)
+{
+    int seg_size = 0;    
+    int shm_fd = -1;   
+    struct shm_map_data * shm_map_ptr = (struct shm_map_data *)NULL;
+
+    if(!shm_path || !sem_path || !cache_path){
+	return -1;
+    }
+
+    seg_size = sizeof(struct shm_map_data);
+
+    shm_fd = shm_open(shm_path, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG);
+    if(shm_fd < 0){
+        
+	printf("\nshm_path:%s. errno:%d\n", shm_path, errno);
+        return -1;
+    }   
+ 
+    ftruncate(shm_fd, seg_size);
+
+    shm_map_ptr = (struct shm_map_data *)mmap(NULL, seg_size, PROT_READ|PROT_WRITE, MAP_SHARED, shm_fd, 0); 
+    if(shm_map_ptr == MAP_FAILED){
+	    printf("\nMAP_FAILED. errno:%d.\n", errno);
+    	close(shm_fd);
+        return -1;
+    }
+
+    if(access(cache_path, F_OK) == -1)
+    {
+        munmap(shm_map_ptr, seg_size);
+        close(shm_fd);
+        return -1;
+    }
+ 
+    struct stat sta;
+    stat(cache_path, &sta);
+    int st_size = sta.st_size;
+    if(st_size == 0){
+        munmap(shm_map_ptr, seg_size);
+	    close(shm_fd);
+	    return -1;
+    }
+
+    char *cache_buffer = (char *)malloc(st_size); 
+    if(!cache_buffer){ 
+        munmap(shm_map_ptr, seg_size);
+	    close(shm_fd);
+        return -1;
+    }
+
+    memset(cache_buffer, 0, st_size);
+ 
+    FILE *cache_fp = fopen(cache_path, "r");
+    if(!cache_fp)
+    {
+        free(cache_buffer);   
+        munmap(shm_map_ptr, seg_size);
+	    close(shm_fd);
+        return -1;
+    }
+
+    int cache_len = fread(cache_buffer, 1, st_size, cache_fp);
+    if(st_size != cache_len)
+    {
+        munmap(shm_map_ptr, seg_size);
+        close(shm_fd);
+        free(cache_buffer);
+        fclose(cache_fp);
+        return -1;
+    }
+
+    sem_t * sem_id = sem_open(sem_path, O_CREAT, S_IRUSR | S_IWUSR, 1);
+    if(sem_id == SEM_FAILED){
+        munmap(shm_map_ptr, seg_size);
+	    close(shm_fd);
+        free(cache_buffer);
+        fclose(cache_fp);
+        return -1;
+    }    
+
+    sem_wait(sem_id);
+
+    memcpy(shm_map_ptr->data, cache_buffer, st_size); 
+    
+    shm_map_ptr->size = st_size;
+ 
+    sem_post(sem_id);
+
+    (void)free(cache_buffer);
+    
+    sem_close(sem_id);
+
+    munmap(shm_map_ptr, seg_size);
+   
+    close(shm_fd);
+
+    return 0; 
+}
+
+int dump_shared_memory(const char *shm_path, const char *sem_path, struct shm_map_data *shared_mem)
+{
+    sem_t *sem_id = (sem_t *)NULL;
+    struct shm_map_data *map_ptr = (struct shm_map_data *)NULL;
+    int seg_size = 0;
+    int shm_fd = -1;
+
+    if(!shm_path || !sem_path || !shared_mem){
+	    return -1;
+    }
+
+    seg_size = sizeof(struct shm_map_data);
+
+
+    shm_fd = shm_open(shm_path, O_RDONLY, 0666);
+    if(shm_fd < 0){
+        return -1; 
+    }
+
+    map_ptr = (struct shm_map_data *)mmap(NULL, seg_size, PROT_READ, MAP_SHARED, shm_fd, 0);
+    if(map_ptr == MAP_FAILED){
+        close(shm_fd);
+        return -1;
+    }   
+ 
+    sem_id = sem_open(sem_path, 0);
+    if(SEM_FAILED == sem_id){
+        munmap(map_ptr, seg_size);
+        close(shm_fd);
+        return -1;
+    }
+
+    sem_wait(sem_id);
+    
+    memcpy(shared_mem, map_ptr, sizeof(struct shm_map_data));
+   
+    sem_post(sem_id);
+
+    sem_close(sem_id);
+    
+    munmap(map_ptr, seg_size);
+    close(shm_fd);
+
+    return 0;
+}
+
+int open_file(const char *shm_path, const char *sem_path, char **cache_data, int *cache_size)
+{
+    int res = -1;
+    char *tmp_ptr = (char *)NULL;
+    struct shm_map_data shm_map_tmp;
+
+    memset(&shm_map_tmp, 0, sizeof(struct shm_map_data));
+
+    res = dump_shared_memory(shm_path, sem_path, &shm_map_tmp);
+    if(!res){
+	tmp_ptr = malloc(shm_map_tmp.size);
+        if(!tmp_ptr){
+	    res = -1;
+	    return res;
+	}	
+
+	memset(tmp_ptr, 0, shm_map_tmp.size);
+
+        memcpy(tmp_ptr, shm_map_tmp.data, shm_map_tmp.size);
+
+        *cache_data = tmp_ptr;
+
+        *cache_size = shm_map_tmp.size;
+    }
+
+    return res; 
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.h b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.h
new file mode 100644
index 000000000000..27afea1f2a7f
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/platform.h
@@ -0,0 +1,155 @@
+#ifndef _PLATFORM_SEASTONE_H_
+#define _PLATFORM_SEASTONE_H_
+#include <stdint.h>
+
+#define PREFIX_PATH_LEN 100
+
+//FAN
+#define FAN_COUNT   6
+#define CHASSIS_FAN_COUNT 4
+#define PSU_FAN_COUNT 2
+
+//PSU
+#define PSU_COUNT 2
+#define PSU_STA_REGISTER 0xA160
+#define PSU_LED_REGISTER 0xA160
+
+//THERMAL
+#define THERMAL_COUNT 13
+#define THERMAL_REGISTER 0xA176
+#define CHASSIS_THERMAL_COUNT 9
+
+//ALARM
+#define ALARM_REGISTER 0xA163
+
+//LED
+#define LED_COUNT   8
+
+#define LED_SYSTEM_H  1
+#define LED_SYSTEM_REGISTER 0xA162
+#define LED_SYSTEM_BOTH 3
+#define LED_SYSTEM_GREEN 1
+#define LED_SYSTEM_YELLOW 2
+#define LED_SYSTEM_OFF 3
+#define LED_SYSTEM_4_HZ 2
+#define LED_SYSTEM_1_HZ 1
+
+#define LED_FAN1_H   5
+#define LED_FAN2_H   6
+#define LED_FAN4_H   7
+#define LED_FAN5_H   8
+#define LED_FAN1_REGISTER 0xA141
+#define LED_FAN2_REGISTER 0xA145
+#define LED_FAN4_REGISTER 0xA14D
+#define LED_FAN5_REGISTER 0xA151
+#define LED_ALARM_H   2
+#define LED_PSU1_H   3
+#define LED_PSU2_H   3
+#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))
+
+#define ONLP_SENSOR_CACHE_SHARED "/onlp-sensor-cache-shared"
+#define ONLP_FRU_CACHE_SHARED "/onlp-fru-cache-shared"
+#define ONLP_SENSOR_LIST_CACHE_SHARED "/onlp-sensor-list-cache-shared"
+
+#define ONLP_SENSOR_CACHE_SEM "/onlp-sensor-cache-sem"
+#define ONLP_FRU_CACHE_SEM "/onlp-fru-cache-sem"
+#define ONLP_SENSOR_LIST_SEM "/onlp-sensor-list-cache-sem"
+
+#define ONLP_SENSOR_CACHE_FILE "/tmp/onlp-sensor-cache.txt"
+#define ONLP_FRU_CACHE_FILE "/tmp/onlp-fru-cache.txt"
+#define ONLP_SENSOR_LIST_FILE "/tmp/onlp-sensor-list-cache.txt"
+
+#define PSUL_ID 1
+#define PSUR_ID 2
+
+#define NUM_OF_CPLD 1
+
+#define USE_SHM_METHOD 0
+
+struct shm_map_data{
+    char data[16384]; 
+    int size;
+}; 
+
+struct device_info{
+	char serial_number[256];
+	char model[256];
+	int airflow;
+};
+
+struct fan_config_p{
+    uint16_t pwm_reg;
+	uint16_t ctrl_sta_reg;
+	uint16_t rear_spd_reg;
+    uint16_t front_spd_reg;
+};
+
+struct led_reg_mapper{
+    char *name;
+    uint16_t device;
+    uint16_t dev_reg;
+};
+
+struct psu_reg_bit_mapper{
+    uint16_t sta_reg;
+    uint8_t bit_present;
+    uint8_t bit_ac_sta;
+    uint8_t bit_pow_sta;
+};
+
+struct search_psu_sdr_info_mapper{
+	char* keyword;
+	char unit;
+};
+
+typedef struct psuInfo_p
+{
+    unsigned int lvin;
+	unsigned int liin;
+	unsigned int lvout;
+	unsigned int liout;
+	unsigned int lpout;
+	unsigned int lpin;
+	unsigned int ltemp;
+	
+	unsigned int rvin;
+	unsigned int riin;
+	unsigned int rvout;
+	unsigned int riout;
+	unsigned int rpout;
+	unsigned int rpin;
+	unsigned int rtemp;
+}psuInfo_p;
+
+#define SYS_CPLD_PATH "/sys/devices/platform/sys_cpld/"
+#define PLATFORM_PATH "/sys/devices/platform/questone2a/"
+#define I2C_DEVICE_PATH "/sys/bus/i2c/devices/"
+#define PREFIX_PATH_ON_SYS_EEPROM "/sys/bus/i2c/devices/i2c-1/1-0056/eeprom"
+
+uint8_t get_led_status(int id);
+int get_psu_model_sn(int id,char* model,char* serial_number);
+
+int get_psu_info(int id,int *mvin,int *mvout,int *mpin,int *mpout,int *miin,int *miout);
+char* trim (char *s);
+int get_fan_info(int id,char* model,char* serial,int *get_fan_info);
+int get_sensor_info(int id, int *temp, int *warn, int *error, int *shutdown);
+int read_device_node_binary(char *filename, char *buffer, int buf_size, int data_len);
+int read_device_node_string(char *filename, char *buffer, int buf_size, int data_len);
+int get_fan_speed(int id,int* per,int* rpm);
+uint8_t get_psu_status(int id);
+int dump_shared_memory(const char *shm_path, const char *sem_path, struct shm_map_data *shared_mem);
+int fill_shared_memory(const char *shm_path, const char *sem_path, const char *cache_path);
+int open_file(const char *shm_path, const char *sem_path, char **cache_data, int *cache_size);
+int create_cache();
+void update_shm_mem(void);
+int is_cache_exist();
+
+#define DEBUG_MODE 0
+
+#if (DEBUG_MODE == 1)
+    #define DEBUG_PRINT(format, ...)   printf(format, __VA_ARGS__)
+#else
+    #define DEBUG_PRINT(format, ...)
+#endif
+
+#endif /* _PLATFORM_SEASTONE_H_ */
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/psui.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/psui.c
new file mode 100644
index 000000000000..9aa9b80fad85
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/psui.c
@@ -0,0 +1,82 @@
+#include <onlp/platformi/psui.h>
+#include "platform.h"
+
+static onlp_psu_info_t psu_info[] =
+    {
+        {},
+        {
+            {ONLP_PSU_ID_CREATE(PSUL_ID), "PSU-Left", 0},
+            "",
+            "",
+            0,
+            ONLP_PSU_CAPS_AC | ONLP_PSU_CAPS_VIN | ONLP_PSU_CAPS_VOUT | ONLP_PSU_CAPS_IIN | ONLP_PSU_CAPS_IOUT | ONLP_PSU_CAPS_PIN | ONLP_PSU_CAPS_POUT,
+        },
+        {
+            {ONLP_PSU_ID_CREATE(PSUR_ID), "PSU-Right", 0},
+            "",
+            "",
+            0,
+            ONLP_PSU_CAPS_AC | ONLP_PSU_CAPS_VIN | ONLP_PSU_CAPS_VOUT | ONLP_PSU_CAPS_IIN | ONLP_PSU_CAPS_IOUT | ONLP_PSU_CAPS_PIN | ONLP_PSU_CAPS_POUT,
+        }};
+
+static const struct psu_reg_bit_mapper psu_mapper[PSU_COUNT + 1] = {
+    {},
+    {0xa160, 5, 0, 3},
+    {0xa160, 4, 0, 2},
+};
+
+uint8_t psu_status = 0;
+
+struct psuInfo_p temp_info[] = {
+    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}};
+
+int onlp_psui_init(void)
+{
+    return ONLP_STATUS_OK;
+}
+
+int onlp_psui_info_get(onlp_oid_t id, onlp_psu_info_t *info_p)
+{
+    int psu_id,psu_offset=0;;
+    psu_id = ONLP_OID_ID_GET(id);
+    *info_p = psu_info[psu_id];
+
+    int present_status=0,pow_status=0;
+    
+    if(psu_status == 0)
+        psu_status = get_psu_status(psu_id);
+    
+    present_status = (psu_status >> psu_mapper[psu_id].bit_present) & 0x01;
+    pow_status = (psu_status >> psu_mapper[psu_id].bit_pow_sta) & 0x01;
+
+    if (present_status == 0)
+    {
+        info_p->status |= ONLP_PSU_STATUS_PRESENT;
+        if (pow_status == 0)
+            info_p->status |= ONLP_PSU_STATUS_UNPLUGGED;
+    }
+    else
+    {
+        info_p->status = ONLP_PSU_STATUS_FAILED;
+    }
+
+    get_psu_model_sn(psu_id,info_p->model,info_p->serial);
+
+    get_psu_info(psu_id,&(info_p->mvin),&(info_p->mvout),&(info_p->mpin),&(info_p->mpout),&(info_p->miin),&(info_p->miout));
+
+    if((info_p->mvin == 0) && (info_p->mpin == 0) && (info_p->miin == 0)){
+        info_p->status |= ONLP_PSU_STATUS_UNPLUGGED;
+    }
+
+    if(psu_id == 1){
+        psu_offset = 1;
+    }else if(psu_id == 2){
+        psu_offset = 3;
+    }
+
+    info_p->hdr.coids[0] = ONLP_THERMAL_ID_CREATE(psu_offset + CHASSIS_THERMAL_COUNT);
+    info_p->hdr.coids[1] = ONLP_THERMAL_ID_CREATE(psu_offset+1 + CHASSIS_THERMAL_COUNT);
+    info_p->hdr.coids[2] = ONLP_FAN_ID_CREATE(psu_id + CHASSIS_FAN_COUNT);
+
+    return ONLP_STATUS_OK;
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sfpi.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sfpi.c
new file mode 100644
index 000000000000..1aaebbbe5b80
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sfpi.c
@@ -0,0 +1,203 @@
+/************************************************************
+ * <bsn.cl fy=2014 v=onl>
+ *
+ *        Copyright 2014, 2015 Big Switch Networks, Inc.
+ *
+ * Licensed under the Eclipse Public License, Version 1.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *        http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the
+ * License.
+ *
+ * </bsn.cl>
+ ************************************************************
+ *
+ *
+ ********************************************************** */
+#include <onlp/platformi/sfpi.h>
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+#include "x86_64_cel_questone_2a_log.h"
+#include "platform.h"
+
+static int qsfp_count__ = 8;
+static int sfp_count__ = 48;
+static int sfp_bus_offset = 1;
+static char node_path[PREFIX_PATH_LEN] = {0};
+char command[256];
+char buf[256];
+FILE *fp;
+
+static int cel_questone_2a_qsfp_sfp_node_read_int(char *path, int *value, int data_len)
+{
+    int ret = 0;
+    char buf[8];
+    *value = 0;
+
+    ret = read_device_node_string(path, buf, sizeof(buf), data_len);
+    if (ret == 0) {
+        int is_not_present = atoi(buf);
+        if (!is_not_present)
+        {
+            *value = !is_not_present;
+        }
+    }
+    return ret;
+}
+
+static char * cel_questone_2a_sfp_qsfp_get_port_path(int port, char *node_name)
+{
+    if (port <= qsfp_count__ + sfp_count__)
+    {
+        if (port > sfp_count__)
+        {
+            sprintf(node_path, "%sSFF/QSFP%d/qsfp_modprs", PLATFORM_PATH, port - sfp_count__);
+        }
+        else
+        {
+            sprintf(node_path, "%sSFF/SFP%d/sfp_modabs", PLATFORM_PATH, port);
+        }
+    }
+    else
+    {
+        AIM_LOG_ERROR("Number of port config is mismatch port(%d)\r\n", port);
+        return "";
+    }
+    return node_path;
+}
+
+static char * cel_questone_2a_sfp_qsfp_get_eeprom_path(int port, char *node_name)
+{
+    if (port <= qsfp_count__ + sfp_count__)
+    {
+        sprintf(node_path, "%s/%d-0050/eeprom", I2C_DEVICE_PATH, port + sfp_bus_offset);
+    }
+    else
+    {
+        AIM_LOG_ERROR("Number of port config is mismatch port(%d)\r\n", port);
+        return "";
+    }
+    return node_path;
+}
+
+static uint64_t cel_questone_2a_sfp_qsfp_get_all_ports_present(void)
+{
+    int i, ret;
+    uint64_t present = 0;
+    char *path;
+
+    for (i = 0; i < (qsfp_count__ + sfp_count__); i++)
+    {
+        path = cel_questone_2a_sfp_qsfp_get_port_path(i + 1, "present");
+        if (cel_questone_2a_qsfp_sfp_node_read_int(path, &ret, 0) != 0)
+        {
+            ret = 0;
+        }
+        present |= ((uint64_t)ret << i);
+    }
+
+    return present;
+}
+
+int onlp_sfpi_init(void)
+{
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sfpi_bitmap_get(onlp_sfp_bitmap_t *bmap)
+{
+    int p;
+    AIM_BITMAP_CLR_ALL(bmap);
+
+    for (p = 0; p < (qsfp_count__ + sfp_count__); p++)
+    {
+        AIM_BITMAP_SET(bmap, p);
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+/*
+* Return 1 if present.
+* Return 0 if not present.
+* Return < 0 if error.
+*/
+int onlp_sfpi_is_present(int port)
+{
+    int present;
+    char *path = cel_questone_2a_sfp_qsfp_get_port_path(port + 1, "present");
+    if (cel_questone_2a_qsfp_sfp_node_read_int(path, &present, 0) != 0)
+    {
+        if (port <= qsfp_count__)
+        {
+            AIM_LOG_ERROR("Unable to read present status from qsfp port(%d)\r\n", port);
+        }
+        else
+        {
+            AIM_LOG_ERROR("Unable to read present status from sfp port(%d)\r\n", port - qsfp_count__);
+        }
+
+        return ONLP_STATUS_E_INTERNAL;
+    }
+    return present;
+}
+
+int onlp_sfpi_presence_bitmap_get(onlp_sfp_bitmap_t *dst)
+{
+    int i = 0;
+    uint64_t presence_all = 0;
+
+    presence_all = cel_questone_2a_sfp_qsfp_get_all_ports_present();
+
+    /* Populate bitmap */
+    for (i = 0; presence_all; i++)
+    {
+        AIM_BITMAP_MOD(dst, i, (presence_all & 1));
+        presence_all >>= 1;
+    }
+    return ONLP_STATUS_OK;
+}
+
+/*
+ * This function reads the SFPs idrom and returns in
+ * in the data buffer provided.
+ */
+int onlp_sfpi_eeprom_read(int port, uint8_t data[256])
+{
+    char *path;
+
+    path = cel_questone_2a_sfp_qsfp_get_eeprom_path(port + 1, "eeprom");
+
+    /*
+     * Read the SFP eeprom into data[]
+     *
+     * Return MISSING if SFP is missing.
+     * Return OK if eeprom is read
+     */
+    memset(data, 0, 256);
+    if (read_device_node_binary(path, (char*)data, 256, 256) != 0) {
+        AIM_LOG_ERROR("Unable to read eeprom from port(%d)\r\n", port);
+        return ONLP_STATUS_E_INTERNAL;
+    }
+
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sfpi_rx_los_bitmap_get(onlp_sfp_bitmap_t *dst)
+{
+    return ONLP_STATUS_OK;
+}
+
+/*
+ * De-initialize the SFPI subsystem.
+ */
+int onlp_sfpi_denit(void)
+{
+    return ONLP_STATUS_OK;
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sysi.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sysi.c
new file mode 100644
index 000000000000..7a1535741c30
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/sysi.c
@@ -0,0 +1,135 @@
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <onlplib/file.h>
+#include <onlp/platformi/thermali.h>
+#include <onlp/platformi/fani.h>
+#include <onlp/platformi/sysi.h>
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+#include "x86_64_cel_questone_2a_int.h"
+#include "x86_64_cel_questone_2a_log.h"
+#include "platform.h"
+//Below include add for support Cache system
+#include <sys/stat.h>
+#include <time.h>
+#include <sys/mman.h>
+#include <semaphore.h>
+
+static char arr_cplddev_name[NUM_OF_CPLD][10] =
+{
+        "version"
+};
+
+const char *onlp_sysi_platform_get(void)
+{
+    return "x86-64-cel-questone-2a-r0";
+}
+
+int onlp_sysi_init(void)
+{
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sysi_platform_info_get(onlp_platform_info_t *pi)
+{
+    int i, v[NUM_OF_CPLD] = {0};
+    char r_data[10] = {0};
+    char fullpath[PREFIX_PATH_LEN] = {0};
+
+    for (i = 0; i < NUM_OF_CPLD; i++)
+    {
+        memset(fullpath, 0, PREFIX_PATH_LEN);
+        sprintf(fullpath, "%s%s", SYS_CPLD_PATH, arr_cplddev_name[i]);
+        if (read_device_node_string(fullpath, r_data, sizeof(r_data), 0) != 0)
+        {
+            DEBUG_PRINT("%s(%d): read %s error\n", __FUNCTION__, __LINE__, fullpath);
+            return ONLP_STATUS_E_INTERNAL;
+        }
+        v[i] = strtol(r_data, NULL, 0);
+    }
+    pi->cpld_versions = aim_fstrdup("CPLD_B=0x%02x", v[0]);
+    return 0;
+}
+
+void onlp_sysi_platform_info_free(onlp_platform_info_t *pi)
+{
+    aim_free(pi->cpld_versions);
+}
+
+int onlp_sysi_onie_data_get(uint8_t **data, int *size)
+{
+    uint8_t *rdata = aim_zmalloc(256);
+
+    if (onlp_file_read(rdata, 256, size, PREFIX_PATH_ON_SYS_EEPROM) == ONLP_STATUS_OK)
+    {
+        if (*size == 256)
+        {
+            *data = rdata;
+            return ONLP_STATUS_OK;
+        }
+    }
+    aim_free(rdata);
+    rdata = NULL;
+    *size = 0;
+    DEBUG_PRINT("[Debug][%s][%d][Can't get onie data]\n", __FUNCTION__, __LINE__);
+    return ONLP_STATUS_E_INTERNAL;
+}
+
+void onlp_sysi_onie_data_free(uint8_t *data)
+{
+    aim_free(data);
+}
+
+int onlp_sysi_platform_manage_init(void)
+{
+    if (is_cache_exist() < 1)
+    {
+        create_cache();
+    }
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sysi_platform_manage_fans(void)
+{
+    if (is_cache_exist() < 1)
+    {
+        create_cache();
+    }
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sysi_platform_manage_leds(void)
+{
+    if (is_cache_exist() < 1)
+    {
+        create_cache();
+    }
+    return ONLP_STATUS_OK;
+}
+
+int onlp_sysi_oids_get(onlp_oid_t *table, int max)
+{
+    int i;
+    onlp_oid_t *e = table;
+
+    memset(table, 0, max * sizeof(onlp_oid_t));
+
+    /* 2 PSUs */
+    *e++ = ONLP_PSU_ID_CREATE(1);
+    *e++ = ONLP_PSU_ID_CREATE(2);
+
+    // // /* LEDs Item */
+    for (i = 1; i <= LED_COUNT; i++)
+        *e++ = ONLP_LED_ID_CREATE(i);
+
+    // // /* THERMALs Item */
+    for (i = 1; i <= CHASSIS_THERMAL_COUNT; i++)
+        *e++ = ONLP_THERMAL_ID_CREATE(i);
+
+    // /* Fans Item */
+    for (i = 1; i <= CHASSIS_FAN_COUNT; i++)
+        *e++ = ONLP_FAN_ID_CREATE(i);
+
+    return ONLP_STATUS_OK;
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/thermali.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/thermali.c
new file mode 100644
index 000000000000..e8bc9bed7d9d
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/thermali.c
@@ -0,0 +1,94 @@
+#include <unistd.h>
+#include <onlplib/mmap.h>
+#include <onlplib/file.h>
+#include <onlp/platformi/thermali.h>
+#include <fcntl.h>
+#include "platform.h"
+
+static onlp_thermal_info_t thermal_info[] = {
+    { },
+    { { ONLP_THERMAL_ID_CREATE(1), "Base_Temp_U5",    0},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(2), "Base_Temp_U7", 0},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(3), "CPU_Temp",   0},
+            ONLP_THERMAL_STATUS_PRESENT,
+            ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+        },
+    { { ONLP_THERMAL_ID_CREATE(4), "Switch_Temp_U31",   0},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(5), "Switch_Temp_U30",   0},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(6), "Switch_Temp_U28",   0},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(7), "Switch_U21_Temp",   0},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(7), "Switch_U33_Temp",   0},
+            ONLP_THERMAL_STATUS_PRESENT,
+            ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+        },
+    { { ONLP_THERMAL_ID_CREATE(7), "Switch_Temp_U29",   0},
+            ONLP_THERMAL_STATUS_PRESENT,
+            ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+        },    
+    { { ONLP_THERMAL_ID_CREATE(8), "PSUL_Temp1",   ONLP_PSU_ID_CREATE(1)},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(9), "PSUL_Temp2",   ONLP_PSU_ID_CREATE(1)},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(10), "PSUR_Temp1",   ONLP_PSU_ID_CREATE(2)},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+    { { ONLP_THERMAL_ID_CREATE(11), "PSUR_Temp2",   ONLP_PSU_ID_CREATE(2)},
+                ONLP_THERMAL_STATUS_PRESENT,
+                ONLP_THERMAL_CAPS_ALL, 0, ONLP_THERMAL_THRESHOLD_INIT_DEFAULTS
+            },
+};
+
+int onlp_thermali_init(void)
+{
+    return ONLP_STATUS_OK;
+}
+
+int onlp_thermali_info_get(onlp_oid_t id, onlp_thermal_info_t *info_p)
+{
+    int thermal_id;
+    int thermal_status = 0;
+    int temp, warn, err, shutdown;
+
+    thermal_id = ONLP_OID_ID_GET(id);
+    memcpy(info_p, &thermal_info[thermal_id], sizeof(onlp_thermal_info_t));
+
+    /* Get thermal temperature. */
+    thermal_status = get_sensor_info(thermal_id, &temp, &warn, &err, &shutdown);
+    if (-1 == thermal_status)
+    {
+        info_p->status = ONLP_THERMAL_STATUS_FAILED;
+    }
+    else
+    {
+        info_p->status = ONLP_THERMAL_STATUS_PRESENT;
+        info_p->mcelsius = temp;
+        info_p->thresholds.warning = warn;
+        info_p->thresholds.error = err;
+        info_p->thresholds.shutdown = shutdown;
+    }
+
+    return ONLP_STATUS_OK;
+}
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_config.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_config.c
new file mode 100644
index 000000000000..e2feaeeeb9e8
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_config.c
@@ -0,0 +1,76 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+/* <auto.start.cdefs(X86_64_CEL_QUESTONE_2A_CONFIG_HEADER).source> */
+#define __x86_64_cel_questone_2a_config_STRINGIFY_NAME(_x) #_x
+#define __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(_x) __x86_64_cel_questone_2a_config_STRINGIFY_NAME(_x)
+x86_64_cel_questone_2a_config_settings_t x86_64_cel_questone_2a_config_settings[] =
+{
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_LOGGING(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_STDLIB(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_PORTING_INCLUDE_STDLIB_HEADERS(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+#ifdef X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI
+    { __x86_64_cel_questone_2a_config_STRINGIFY_NAME(X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI), __x86_64_cel_questone_2a_config_STRINGIFY_VALUE(X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI) },
+#else
+{ X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI(__x86_64_cel_questone_2a_config_STRINGIFY_NAME), "__undefined__" },
+#endif
+    { NULL, NULL }
+};
+#undef __x86_64_cel_questone_2a_config_STRINGIFY_VALUE
+#undef __x86_64_cel_questone_2a_config_STRINGIFY_NAME
+
+const char*
+x86_64_cel_questone_2a_config_lookup(const char* setting)
+{
+    int i;
+    for(i = 0; x86_64_cel_questone_2a_config_settings[i].name; i++) {
+        if(strcmp(x86_64_cel_questone_2a_config_settings[i].name, setting)) {
+            return x86_64_cel_questone_2a_config_settings[i].value;
+        }
+    }
+    return NULL;
+}
+
+int
+x86_64_cel_questone_2a_config_show(struct aim_pvs_s* pvs)
+{
+    int i;
+    for(i = 0; x86_64_cel_questone_2a_config_settings[i].name; i++) {
+        aim_printf(pvs, "%s = %s\n", x86_64_cel_questone_2a_config_settings[i].name, x86_64_cel_questone_2a_config_settings[i].value);
+    }
+    return i;
+}
+
+/* <auto.end.cdefs(X86_64_CEL_QUESTONE_2A_CONFIG_HEADER).source> */
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_enums.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_enums.c
new file mode 100644
index 000000000000..fa9dfaeaaabd
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_enums.c
@@ -0,0 +1,6 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_int.h b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_int.h
new file mode 100644
index 000000000000..257bbf9bcfb3
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_int.h
@@ -0,0 +1,11 @@
+/**************************************************************************//**
+ *
+ * x86_64_cel_questone_2a Internal Header
+ *
+ *****************************************************************************/
+#ifndef __X86_64_CEL_QUESTONE_2A_INT_H__
+#define __X86_64_CEL_QUESTONE_2A_INT_H__
+
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+#endif /* __X86_64_CEL_QUESTONE_2A_INT_H__ */
\ No newline at end of file
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.c
new file mode 100644
index 000000000000..d3a20acecfee
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.c
@@ -0,0 +1,18 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+#include "x86_64_cel_questone_2a_log.h"
+/*
+ * x86_64_cel_questone_2a log struct.
+ */
+AIM_LOG_STRUCT_DEFINE(
+                      X86_64_CEL_QUESTONE_2A_CONFIG_LOG_OPTIONS_DEFAULT,
+                      X86_64_CEL_QUESTONE_2A_CONFIG_LOG_BITS_DEFAULT,
+                      NULL, /* Custom log map */
+                      X86_64_CEL_QUESTONE_2A_CONFIG_LOG_CUSTOM_BITS_DEFAULT
+                     );
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.h b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.h
new file mode 100644
index 000000000000..19e51fb34af8
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_log.h
@@ -0,0 +1,12 @@
+/**************************************************************************//**
+ *
+ * 
+ *
+ *****************************************************************************/
+#ifndef __X86_64_CEL_QUESTONE_2A_LOG_H__
+#define __X86_64_CEL_QUESTONE_2A_LOG_H__
+
+#define AIM_LOG_MODULE_NAME x86_64_cel_questone_2a
+#include <AIM/aim_log.h>
+
+#endif /* __X86_64_CEL_QUESTONE_2A_LOG_H__ */
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_module.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_module.c
new file mode 100644
index 000000000000..7a1274f4deef
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_module.c
@@ -0,0 +1,24 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+#include "x86_64_cel_questone_2a_log.h"
+
+static int
+datatypes_init__(void)
+{
+#define X86_64_CEL_QUESTONE_2A_ENUMERATION_ENTRY(_enum_name, _desc)     AIM_DATATYPE_MAP_REGISTER(_enum_name, _enum_name##_map, _desc,                               AIM_LOG_INTERNAL);
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a.x>
+    return 0;
+}
+
+void __x86_64_cel_questone_2a_module_init__(void)
+{
+    AIM_LOG_STRUCT_REGISTER();
+    datatypes_init__();
+}
+
+int __onlp_platform_version__ = 1;
diff --git a/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_ucli.c b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_ucli.c
new file mode 100644
index 000000000000..eebeabc0b191
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/onlp/builds/x86_64_cel_questone_2a/module/src/x86_64_cel_questone_2a_ucli.c
@@ -0,0 +1,50 @@
+/**************************************************************************//**
+ *
+ *
+ *
+ *****************************************************************************/
+#include <x86_64_cel_questone_2a/x86_64_cel_questone_2a_config.h>
+
+#if X86_64_CEL_QUESTONE_2A_CONFIG_INCLUDE_UCLI == 1
+
+#include <uCli/ucli.h>
+#include <uCli/ucli_argparse.h>
+#include <uCli/ucli_handler_macros.h>
+
+static ucli_status_t
+x86_64_cel_questone_2a_ucli_ucli__config__(ucli_context_t* uc)
+{
+    UCLI_HANDLER_MACRO_MODULE_CONFIG(x86_64_cel_questone_2a)
+}
+
+/* <auto.ucli.handlers.start> */
+/* <auto.ucli.handlers.end> */
+
+static ucli_module_t
+x86_64_cel_questone_2a_ucli_module__ =
+    {
+        "x86_64_cel_questone_2a_ucli",
+        NULL,
+        x86_64_cel_questone_2a_ucli_ucli_handlers__,
+        NULL,
+        NULL,
+    };
+
+ucli_node_t*
+x86_64_cel_questone_2a_ucli_node_create(void)
+{
+    ucli_node_t* n;
+    ucli_module_init(&x86_64_cel_questone_2a_ucli_module__);
+    n = ucli_node_create("x86_64_cel_questone_2a", NULL, &x86_64_cel_questone_2a_ucli_module__);
+    ucli_node_subnode_add(n, ucli_module_log_node_create("x86_64_cel_questone_2a"));
+    return n;
+}
+
+#else
+void*
+x86_64_cel_questone_2a_ucli_node_create(void)
+{
+    return NULL;
+}
+#endif
+
diff --git a/packages/platforms/celestica/x86-64/questone-2a/platform-config/Makefile b/packages/platforms/celestica/x86-64/questone-2a/platform-config/Makefile
new file mode 100755
index 000000000000..dc1e7b86f0b2
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/platform-config/Makefile
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/Makefile b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/Makefile
new file mode 100755
index 000000000000..dc1e7b86f0b2
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/Makefile
@@ -0,0 +1 @@
+include $(ONL)/make/pkg.mk
diff --git a/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/PKG.yml b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/PKG.yml
new file mode 100755
index 000000000000..f217c73bc899
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/PKG.yml
@@ -0,0 +1 @@
+!include $ONL_TEMPLATES/platform-config-platform.yml ARCH=amd64 VENDOR=celestica BASENAME=x86-64-cel-questone-2a REVISION=r0
diff --git a/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/lib/x86-64-cel-questone-2a-r0.yml b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/lib/x86-64-cel-questone-2a-r0.yml
new file mode 100644
index 000000000000..2012fb0bc825
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/lib/x86-64-cel-questone-2a-r0.yml
@@ -0,0 +1,34 @@
+---
+
+######################################################################
+#
+# platform-config for Celestica Questone
+#
+#
+######################################################################
+
+x86-64-cel-questone-2a-r0:
+
+  grub:
+
+    serial: >-
+      --port=0x3f8
+      --speed=115200
+      --word=8
+      --parity=0
+      --stop=1
+
+    kernel:
+      <<: *kernel-4-14
+
+    args: >-
+      nopat
+      console=ttyS0,115200n8
+      earlycon=uart8250,mmio,0xdff9b000
+      intel_iommu=off
+
+  ##network
+  ##  interfaces:
+  ##    ma1:
+  ##      name: ~
+  ##      syspath: pci0000:00/0000:00:14.0
diff --git a/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/python/x86_64_cel_questone_2a_r0/__init__.py b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/python/x86_64_cel_questone_2a_r0/__init__.py
new file mode 100644
index 000000000000..3338afddaf30
--- /dev/null
+++ b/packages/platforms/celestica/x86-64/questone-2a/platform-config/r0/src/python/x86_64_cel_questone_2a_r0/__init__.py
@@ -0,0 +1,75 @@
+from onl.platform.base import *
+from onl.platform.celestica import *
+
+class OnlPlatform_x86_64_cel_questone_2a_r0(OnlPlatformCelestica,
+                                            OnlPlatformPortConfig_48x25_8x100):
+    PLATFORM='x86-64-cel-questone-2a-r0'
+    MODEL="Questone-2A"
+    SYS_OBJECT_ID=".2060.1"
+
+    def baseconfig(self):
+        onlp_interval_time = 30  # second
+        file_path = "/var/opt/interval_time.txt"
+        qsfp_quantity = 8
+        sfp_quantity = 48
+        sfp_i2c_start_bus = 2
+
+        #Celestica Blacklist file
+        blacklist_file_path="/etc/modprobe.d/celestica-blacklist.conf"
+        #Blacklist the unuse module.
+        if os.path.exists(blacklist_file_path):
+            os.system("rm {0}".format(blacklist_file_path))
+       
+        os.system("touch {0}".format(blacklist_file_path))
+        cel_paths = "/lib/modules/{0}/onl/celestica/".format(os.uname()[2])
+        cel_dirs = os.listdir(cel_paths)
+        for dir in cel_dirs:
+            full_cel_path=cel_paths+dir
+            if os.path.isdir(full_cel_path):
+                modules=os.listdir(full_cel_path)
+                for module in modules:
+                    os.system("echo 'blacklist {0}' >> {1}".format(module[0:-3],blacklist_file_path))
+
+        print("Initialize and Install the driver here")
+        self.insmod("questone2a_switchboard.ko")
+        self.insmod("questone2a_baseboard_cpld.ko")
+        self.insmod("optoe.ko")
+        self.insmod("mc24lc64t.ko")
+
+        # os.system("insmod /lib/modules/`uname -r`/kernel/drivers/char/ipmi/ipmi_devintf.ko")
+        # os.system("insmod /lib/modules/`uname -r`/kernel/drivers/char/ipmi/ipmi_si.ko")
+        # os.system("insmod /lib/modules/`uname -r`/kernel/drivers/char/ipmi/ipmi_ssif.ko")
+
+        # ###### new configuration for SDK support ########
+        # os.system("insmod /lib/modules/`uname -r`/kernel/net/core/pktgen.ko")
+        # os.system("insmod /lib/modules/`uname -r`/kernel/net/core/drop_monitor.ko")
+        # os.system("insmod /lib/modules/`uname -r`/kernel/net/ipv4/tcp_probe.ko")
+
+        # eeprom driver
+        self.new_i2c_device('24lc64t', 0x56, 1)
+        # initialize SFP devices name
+        for actual_i2c_port in range(sfp_i2c_start_bus, sfp_i2c_start_bus+(qsfp_quantity+sfp_quantity)):
+            port_number = actual_i2c_port - (sfp_i2c_start_bus-1)
+            if(port_number <= sfp_quantity):
+                #print("echo 'QSFP{1}' > /sys/devices/i2c-{0}/{0}-0050/port_name".format(actual_i2c_port,port_number))
+                os.system("echo 'SFP{1}' > /sys/devices/i2c-{0}/{0}-0050/port_name".format(actual_i2c_port,port_number))
+            else:
+                #print("echo 'SFP{1}' > /sys/devices/i2c-{0}/{0}-0050/port_name".format(actual_i2c_port,port_number-qsfp_quantity))
+                os.system("echo 'QSFP{1}' > /sys/devices/i2c-{0}/{0}-0050/port_name".format(actual_i2c_port,port_number-sfp_quantity))
+            # self.new_i2c_device('sff8436', 0x50, port)
+            # self.new_i2c_device('as5912_54x_sfp%d' % port, 0x51, port+25)
+        
+        # Script for create interval_time cache.
+        if os.path.exists(file_path):
+            pass
+        else:
+            with open(file_path, 'w') as f:  
+                f.write("{0}\r\n".format(onlp_interval_time))
+            f.close()
+
+        #initialize onlp cache files
+        print("Initialize ONLP Cache files")
+        os.system("ipmitool fru > /tmp/onlp-fru-cache.tmp; sync; rm -f /tmp/onlp-fru-cache.txt; mv /tmp/onlp-fru-cache.tmp /tmp/onlp-fru-cache.txt")
+        os.system("ipmitool sensor list > /tmp/onlp-sensor-list-cache.tmp; sync; rm -f /tmp/onlp-sensor-list-cache.txt; mv /tmp/onlp-sensor-list-cache.tmp /tmp/onlp-sensor-list-cache.txt")
+        
+        return True
-- 
2.42.0

