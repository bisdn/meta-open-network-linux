diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 5ee7cde0c2e9..00911cae7295 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -41,6 +41,11 @@
 	case PHY_##_state:			\
 		return __stringify(_state);	\
 
+#if IS_ENABLED(CONFIG_MDIO_XGS_IPROC)
+#define MAX_IPROC_PHY_ADDR	4
+extern bool xgs_mdio_bus_release(void);
+#endif
+
 static const char *phy_state_to_str(enum phy_state st)
 {
 	switch (st) {
@@ -1149,6 +1154,9 @@ void phy_state_machine(struct work_struct *work)
 	enum phy_state old_state;
 	bool finished = false;
 	int err = 0;
+#if IS_ENABLED(CONFIG_MDIO_XGS_IPROC)
+	static u32 schedule_cnt[MAX_IPROC_PHY_ADDR]= {0};
+#endif
 
 	mutex_lock(&phydev->lock);
 
@@ -1219,8 +1227,30 @@ void phy_state_machine(struct work_struct *work)
 	 * called from phy_disconnect() synchronously.
 	 */
 	mutex_lock(&phydev->lock);
+#if IS_ENABLED(CONFIG_MDIO_XGS_IPROC)
+	if (phy_polling_mode(phydev) && phy_is_started(phydev)) {
+		/* Re-schedule PHY state machine change if mdio_bus_release=0 */
+		if (!xgs_mdio_bus_release()) {
+			phy_queue_state_machine(phydev, PHY_STATE_TIME);
+		}
+		/* If mdio_bus_release=1, stop re-schedule of PHY state machine
+		 * change after 5 * PHY_STATE_TIME seconds for HX4/KT2
+		 * which shares the mdio bus between iProc and CMICd.
+		 */
+		else {
+			schedule_cnt[phydev->mdio.addr] += 1;
+			if (schedule_cnt[phydev->mdio.addr] > 5) {
+				schedule_cnt[phydev->mdio.addr] = 0;
+				mutex_unlock(&phydev->lock);
+				return;
+			}
+			phy_queue_state_machine(phydev, PHY_STATE_TIME);
+		}
+	}
+#else
 	if (phy_polling_mode(phydev) && phy_is_started(phydev))
 		phy_queue_state_machine(phydev, PHY_STATE_TIME);
+#endif
 	mutex_unlock(&phydev->lock);
 }
 
-- 
2.33.0

