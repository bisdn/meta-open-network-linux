From 2b674f9cedb3bd3b8dd31de747a13fe2413f9eca Mon Sep 17 00:00:00 2001
From: Jonas Gorski <jonas.gorski@bisdn.de>
Date: Thu, 7 Oct 2021 10:09:06 +0200
Subject: [PATCH 19/21] watchdog: sp805_wdt: clear bootstatus

---
 drivers/watchdog/sp805_wdt.c | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/drivers/watchdog/sp805_wdt.c b/drivers/watchdog/sp805_wdt.c
index 109e2e37e8f0..9e46f6614610 100644
--- a/drivers/watchdog/sp805_wdt.c
+++ b/drivers/watchdog/sp805_wdt.c
@@ -30,6 +30,8 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/watchdog.h>
+#include <linux/of_address.h>
+
 
 /* default timeout in seconds */
 #define DEFAULT_TIMEOUT		60
@@ -89,6 +91,24 @@ static bool wdt_is_running(struct watchdog_device *wdd)
 	return (wdtcontrol & ENABLE_MASK) == ENABLE_MASK;
 }
 
+/* This routine get boot status to indicate if the last boot is from WDT */
+static unsigned int wdt_get_clear_bootstatus(
+			void __iomem *wdt_bootstatus,
+			unsigned int wdt_bootstatus_bit)
+{
+	unsigned int reg;
+	unsigned int bootstatus = 0;
+
+	reg = readl_relaxed(wdt_bootstatus);
+	bootstatus = reg & (1 << wdt_bootstatus_bit);
+
+	if (bootstatus)
+		/* write 1 to clear boot status bit */
+		writel_relaxed(reg, wdt_bootstatus);
+
+	return bootstatus;
+}
+
 /* This routine finds load value that will reset system in required timeout */
 static int wdt_setload(struct watchdog_device *wdd, unsigned int timeout)
 {
@@ -236,6 +256,8 @@ sp805_wdt_probe(struct amba_device *adev, const struct amba_id *id)
 	struct reset_control *rst;
 	u64 rate = 0;
 	int ret = 0;
+	void __iomem *wdt_bootstatus = NULL;
+	unsigned int bootstatus_bit = 0;
 
 	wdt = devm_kzalloc(&adev->dev, sizeof(*wdt), GFP_KERNEL);
 	if (!wdt) {
@@ -247,6 +269,14 @@ sp805_wdt_probe(struct amba_device *adev, const struct amba_id *id)
 	if (IS_ERR(wdt->base))
 		return PTR_ERR(wdt->base);
 
+	if (adev->dev.of_node) {
+	  	wdt_bootstatus = of_iomap(adev->dev.of_node, 1);
+		if (!wdt_bootstatus) {
+			dev_warn(&adev->dev, "of_iomap failed\n");
+			return -ENOMEM;
+		}
+	}
+
 	/*
 	 * When driver probe with ACPI device, clock devices
 	 * are not available, so watchdog rate get from
@@ -306,6 +336,9 @@ sp805_wdt_probe(struct amba_device *adev, const struct amba_id *id)
 		goto err;
 	amba_set_drvdata(adev, wdt);
 
+  wdt->wdd.bootstatus = wdt_get_clear_bootstatus(
+	                         wdt_bootstatus, bootstatus_bit);
+        
 	dev_info(&adev->dev, "registration successful\n");
 	return 0;
 
-- 
2.47.1

